#!/usr/bin/env bash

sys=$( uname -s )
if [[ "${sys}" = AIX ]] ; then
    name_opt=-name
else
    name_opt=-iname
fi
original_ruby_version=${rvm_ruby_version:-""}
original_ruby_string=${rvm_ruby_string:-""}

source "$rvm_scripts_path/base"
source "$rvm_scripts_path/patches"
source "$rvm_scripts_path/functions/build"
source "$rvm_scripts_path/functions/irbrc"
source "$rvm_scripts_path/functions/db"

unset RUBYLIB RUBYOPT # Sanity check.

__rvm_check_for_clang()
{
  if (( ${rvm_clang_flag:=0} == 1 )) && ! command -v clang >/dev/null
  then
    rvm_error "\nYou passed the --clang option and clang is not in your path. \nPlease try again or do not use --clang.\n"
    return 1
  fi
}

# Checks for bison, returns zero iff it is found
__rvm_check_for_bison()
{
  if (( ${rvm_head_flag:=0} > 0 ))
  then
    command -v bison > /dev/null
    result=$?
    if [[ $result -gt 0 ]] ; then
      rvm_error "\nbison is not available in your path. \nPlease ensure bison is installed before compiling from head.\n"
    fi
  fi
  return ${result:-0}
}

# Emits a number of patches to STDOUT, each on a new name
# Expands patchsets etc.
__rvm_current_patch_names()
{
  # TODO: Lookup default patches on rvm_ruby_string heirarchy.
  local separator patches level name

  separator="%"
  patches="${rvm_patch_names:-""} default"

  for patch_name in $(echo ${patches//,/ })
  do
    level=1
    name="$patch_name"

    if echo "$name" | grep "$separator" >/dev/null 2>&1
    then
      level="${name/*${separator}/}"
      name="${name//${separator}*/}"
    fi

    local expanded_name="$(__rvm_expand_patch_name "$name")"

    echo "${expanded_name}${separator}${level}"

  done

  return 0
}

__rvm_apply_patches()
{
  local patches patch_name patch_level_separator patch_fuzziness patch_level source_directory full_patch_path

  result=0
  patch_level_separator="%"
  patch_fuzziness="25"
  patch_level=1

  source_directory="${1:-""}"

  [[ -n "$source_directory" ]] ||
    source_directory="${rvm_src_path}/$rvm_ruby_string"

  (
    builtin cd "$source_directory"

    patches=($(__rvm_current_patch_names))

    for patch_name in "${patches[@]}" ; do

      # If set, extract the patch level from the patch name.
      patch_level=1

      if echo "$patch_name" | \grep "$patch_level_separator" >/dev/null 2>&1; then
        patch_level=${patch_name//*${patch_level_separator}/}
        patch_name="${patch_name//${patch_level_separator}*/}"
      fi

      full_patch_path="$(__rvm_lookup_full_patch_path "$patch_name")"

      # Expand paths, and for those we found we then apply the patches.
      if [[ -n "${full_patch_path:-""}" ]]
      then
        if [[ -f "$full_patch_path" ]]
        then
          __rvm_run "patch.apply.${patch_name/*\/}" \
            "patch -F$patch_fuzziness -p$patch_level -f <\"$full_patch_path\"" \
            "Applying patch '$patch_name' (located at $full_patch_path)"

          (( $? == 0 )) || result=1 # Detect failed patches
        fi

      else
        rvm_warn "Patch '$patch_name' not found."
        result=1
      fi
    done
  )

  return ${result:-0}
}

__rvm_install_source()
{
  local directory configure_parameters db_configure_flags

  if (( ${rvm_ruby_selected_flag:=0} == 0 ))
  then
    __rvm_select
  fi

  case ${rvm_ruby_string:-""} in
    ruby-head|1.9.*-head)
      if ! __rvm_ensure_has_18_compat_ruby
      then
        return 1
      fi
      ;;
  esac

  rvm_log "Installing Ruby from source to: $rvm_ruby_home, this may take a while depending on your cpu(s)...\n"

  builtin cd "${rvm_src_path}"

  if [[ ${rvm_force_flag:-0} -eq 1 ]] ; then

    for directory in "$rvm_ruby_home" "${rvm_src_path}/$rvm_ruby_string" ; do

      __rvm_rm_rf "$directory"

    done
  fi

  result=0

  __rvm_fetch_ruby
  result=$?

  if (( result > 0 ))
  then
    rvm_error "There has been an error fetching the ruby interpreter. Halting the installation."
    return $result
  fi

  builtin cd "${rvm_src_path}/$rvm_ruby_string"
  result=$?
  if (( result > 0 ))
  then
    rvm_error "Source directory is missing.  \nDid the download or extraction fail?  \nHalting the installation."
    return $result
  fi

  if [[ -d "${rvm_path}/usr" ]] ; then
    export PATH="${rvm_path}/usr/bin:${PATH}"

    builtin hash -r
  fi

  if (( ${rvm_static_flag:=0} == 1 ))
  then
    if [[ -s "ext/Setup" ]]; then
      echo 'option nodynamic' >> ext/Setup
      rvm_log "Setting option nodynamic (static)."
    else
      rvm_log "
      You asked for static Ruby compilation however the file ext/Setup
      appears to be missing from the source directory
      ${rvm_src_path}/$rvm_ruby_string
      please investigate this, continuing installation regardless.
      "
    fi
  fi

  __rvm_apply_patches
  result="$?"

  if (( result > 0 ))
  then
    rvm_error "There has been an error applying the specified patches. Halting the installation."
    return $result
  fi

  if [[ -z "${rvm_ruby_configure:-""}" \
    && (! -s "${rvm_src_path}/$rvm_ruby_string/configure" \
        || "${rvm_src_path}/$rvm_ruby_string/configure.in" -nt "${rvm_src_path}/$rvm_ruby_string/configure") ]] ; then

    if command -v autoconf > /dev/null ; then

      __rvm_run "autoconf" "autoconf" "Running autoconf"

    else
      rvm_error "rvm requires autoconf to install the selected ruby interpreter however autoconf was not found in the PATH."
      return 1
    fi
  fi

  if [[ -n "${rvm_ruby_configure:-""}" ]] ; then

    __rvm_run "configure" "$rvm_ruby_configure"
    result=$?

    if [[ $result -gt 0 ]] ; then
      rvm_error "There has been an error while configuring. Halting the installation."
      return $result
    fi

  elif [[ -s ./configure ]] ; then

    # REE stores configure flags differently for head vs. the distributed release.
    if [[ "ree" != "${rvm_ruby_interpreter:-""}" ]]; then
      __rvm_db "${rvm_ruby_interpreter}_configure_flags" "db_configure_flags"
    fi

    # On 1.9.2, we manually set the --with-baseruby option
    # to point to an expanded path.
    if [[ "${rvm_ruby_string:-""}" = "ruby-1.9.2-head" ]]
    then
      local compatible_baseruby="$rvm_wrappers_path/$(__rvm_18_compat_ruby)/ruby"
      if [[ -x "$compatible_baseruby" ]]
      then
        configure_parameters="--with-baseruby=$compatible_baseruby"
      fi
    fi

    local configure_command="${rvm_configure_env:-""} ./configure --prefix=$rvm_ruby_home ${db_configure_flags:-""} ${rvm_configure_flags:-""} ${configure_parameters:-""}"

    __rvm_run "configure" "$configure_command" "$rvm_ruby_string - #configuring "
    result=$?

    if (( result > 0 ))
    then
      rvm_error "There has been an error while running configure. Halting the installation."
      return $result
    fi

  else
    rvm_error "Skipping configure step, 'configure' does not exist, did autoconf not run successfully?"
  fi

  rvm_ruby_make=${rvm_ruby_make:-"make"}

  __rvm_run "make" "$rvm_ruby_make ${rvm_make_flags:-""}" "$rvm_ruby_string - #compiling "
  result=$?

  if (( result > 0 ))
  then
    rvm_error "There has been an error while running make. Halting the installation."
    return $result
  fi

  __rvm_rm_rf "$PWD/.ext/rdoc"

  rvm_ruby_make_install=${rvm_ruby_make_install:-"make install"}

  __rvm_run "install" "$rvm_ruby_make_install" "$rvm_ruby_string - #installing "
  result=$?
  if (( result > 0 ))
  then
    rvm_error "There has been an error while running make install. Halting the installation."
    return $result
  fi

  export GEM_HOME="$rvm_ruby_gem_home"
  export GEM_PATH="$rvm_ruby_gem_path"

  case "$rvm_ruby_string" in
    ruby-1.8*)
      version="${rvm_ruby_version//*.}"
      if [[ $version -lt 7 ]] ; then
        "$rvm_scripts_path/rubygems" 1.3.7
      else
        "$rvm_scripts_path/rubygems" latest
      fi
      ;;
    *)
      "$rvm_scripts_path/rubygems" latest
      ;;
  esac
  result=$?

  __rvm_bin_script

  __rvm_run "chmod.bin" "chmod +x $rvm_ruby_home/bin/*"

  __rvm_post_install
  result=$?

  rvm_log "Install of $rvm_ruby_string - #complete "

  return ${result:-0}
}

__rvm_install_ruby()
{
  if (( ${rvm_ruby_selected_flag:=0} == 0 ))
  then
    __rvm_select
  fi

  if [[ -n "${RUBYOPT:-""}" ]]
  then
    ruby_options="$RUBYOPT"
  fi

  unset RUBYOPT

  # Check for clang if the flag is set
  __rvm_check_for_clang
  result=$?
  if (( result > 0 ))
  then
    return $result
  fi

  case "$rvm_ruby_interpreter" in
    macruby)
      if [[ "Darwin" = "$(uname)" ]] ; then

        if (( ${rvm_head_flag:=0} == 1 ))
        then
          if (( ${rvm_llvm_flag:=0} == 1 ))
          then
            "$rvm_scripts_path/package" llvm install
          fi

          macruby_path="/usr/local/bin"
          # TODO: configure & make variables should be set here.
          rvm_ruby_configure=" true "
          rvm_ruby_make="rake"
          rvm_ruby_make_install="$rvm_bin_path/rvmsudo rake install"

          __rvm_db "${rvm_ruby_interpreter}_repo_url" "rvm_ruby_url"

          rvm_ruby_repo_url=$rvm_ruby_url

          __rvm_install_source $*
          result=$?

          if (( result > 0 ))
          then
            rvm_error "There has been an error while trying to install from source. \nHalting the installation."
            return $result
          fi

        elif [[ "nightly" = "$rvm_ruby_version" ]] ; then
          __rvm_db "macruby_nightly_version" "macruby_nightly_version"
          macruby_path="/Library/Frameworks/MacRuby.framework/Versions/${macruby_nightly_version}/usr/bin"
          unset macruby_nightly_version
          # TODO: Separated nightly from head.

          rvm_log "Retrieving the latest nightly macruby build..."

          "$rvm_scripts_path/fetch" "$rvm_ruby_url"
          result=$?
          if (( result > 0 ))
          then
            rvm_error "There has been an error while trying to fetch the source.  \nHalting the installation."
            return $result
          fi

          mv "${rvm_archives_path}/macruby_nightly-latest.pkg" \
            "${rvm_archives_path}/macruby_nightly.pkg"

          __rvm_run "macruby/extract" \
            "sudo /usr/sbin/installer -pkg '${rvm_archives_path}/macruby_nightly.pkg' -target '/'"

          mkdir -p "$rvm_ruby_home/bin"

        else
          macruby_path="/Library/Frameworks/MacRuby.framework/Versions/${rvm_ruby_version}/usr/bin"

          # TODO: Separated nightly from head.
          rvm_log "Retrieving MacRuby ${rvm_ruby_version} ..."

          "$rvm_scripts_path/fetch" "$rvm_ruby_url"

          result=$?

          if (( result > 0 ))
          then
            rvm_error "There has been an error while trying to fetch the source. Halting the installation."
            return $result
          fi

          mkdir -p ${rvm_src_path}/$rvm_ruby_string

          unzip -o -j "${rvm_archives_path}/$rvm_ruby_package_file" \
            "MacRuby ${rvm_ruby_version}/MacRuby ${rvm_ruby_version}.pkg" \
            -d "${rvm_src_path}/$rvm_ruby_string"

          mv "${rvm_src_path}/$rvm_ruby_string/MacRuby ${rvm_ruby_version}.pkg" \
            "${rvm_src_path}/$rvm_ruby_string/$rvm_ruby_string.pkg"

          __rvm_run "macruby/extract" \
            "sudo /usr/sbin/installer -pkg '${rvm_src_path}/$rvm_ruby_string/$rvm_ruby_string.pkg' -target '/'"

          mkdir -p "$rvm_ruby_home/bin"
        fi

        binaries=(erb gem irb rake rdoc ri ruby testrb)
        for binary_name in ${binaries[@]}; do
          # TODO: This should be generated via an external script.
          ruby_wrapper=$(cat <<RubyWrapper
#!/usr/bin/env bash

export GEM_HOME="\${GEM_HOME:-$rvm_ruby_gem_home}"
export GEM_PATH="\${GEM_PATH:-$rvm_ruby_gem_path}"
export MY_RUBY_HOME="$rvm_ruby_home"
export PATH="$rvm_ruby_gem_home/bin:$rvm_ruby_global_gems_path/bin:$rvm_ruby_home/bin:\$PATH"

exec "$macruby_path/mac$binary_name" "\$@"
RubyWrapper
)

          file_name="$rvm_ruby_home/bin/$binary_name"

          [[ ! -f "$file_name" ]] || rm -f "$file_name"

          echo "$ruby_wrapper" > "$file_name"

          [[ -x "$file_name" ]] || chmod +x $file_name

          if [[ "$binary_name" = "ruby" ]] ; then
            echo "$ruby_wrapper" \
              > "${rvm_bin_path:-"$rvm_bin_path/bin"}/$rvm_ruby_string"
          fi
        done ; unset binaries

        __rvm_irbrc

      else
        rvm_error "MacRuby can only be installed on a Darwin OS."
      fi
    ;;

    ree)
      if [[ -n "$(echo "$rvm_ruby_version" | awk '/^1\.8/')" ]] &&
        (( ${rvm_head_flag:=0} == 0 ))
      then
        rvm_ruby_url="$(__rvm_db "ree_${rvm_ruby_version}_url")/$rvm_ruby_package_file.tar.gz"

        rvm_log "Installing Ruby Enterprise Edition from source to: $rvm_ruby_home"

        builtin cd "${rvm_src_path}"

        if (( ${rvm_force_flag:=0} == 0 )) &&
          [[ -d "${rvm_src_path}/$rvm_ruby_string" &&
          ! -x "${rvm_src_path}/$rvm_ruby_string/installer" ]]
        then
          rvm_log "It appears that the archive has already been extracted. Skipping extract (use --force to force re-download and extract)."

        else
          rvm_log "$rvm_ruby_string - #fetching ($rvm_ruby_package_file)"

          "$rvm_scripts_path/fetch" "$rvm_ruby_url"
          result=$?

          if (( result > 0 ))
          then
            rvm_error "There has been an error while trying to fetch the source. \nHalting the installation."
            return $result
          fi

          __rvm_rm_rf "${rvm_src_path}/$rvm_ruby_string"

          __rvm_run "extract" \
            "gunzip < \"${rvm_archives_path}/$rvm_ruby_package_file.$rvm_archive_extension\" | tar xf - -C ${rvm_src_path}"  --no-same-owner \
            "$rvm_ruby_string - #extracting $rvm_ruby_package_file to ${rvm_src_path}/$rvm_ruby_string"
          result=$?

          if (( result > 0 ))
          then
            rvm_error "There has been an error while trying to extract the source. Halting the installation."
            return $result
          fi

          mv "${rvm_src_path}/$rvm_ruby_package_file" \
            "${rvm_src_path}/$rvm_ruby_string"
        fi

        builtin cd "${rvm_src_path}/$rvm_ruby_string"

        # wait, what? v v v TODO: Investigate line smell.
        mkdir -p "${rvm_ruby_home}/lib/ruby/gems/1.8/gems"

        [[ -z "$rvm_configure_flags" ]] ||
          rvm_configure_flags="${rvm_configure_flags//--/-c --}"

        if [[ "Darwin" = "$(uname)" && ("1.8.6" = "$rvm_ruby_version" || "1.8.7" = "$rvm_ruby_version") \
          && -z "$rvm_ree_options" ]] ; then
          rvm_ree_options="${rvm_ree_options} --no-tcmalloc"
        fi

        __rvm_db "${rvm_ruby_interpreter}_configure_flags" "db_configure_flags"

        __rvm_apply_patches "${rvm_src_path}/$rvm_ruby_string/source"
        result=$?

        if (( result > 0 ))
        then
          rvm_error "There has been an error while trying to apply patches to ree. \nHalting the installation."
          return $result
        fi

        __rvm_run "install" \
          "./installer -a $rvm_rubies_path/$rvm_ruby_string $rvm_ree_options $db_configure_flags $rvm_configure_flags" "$rvm_ruby_string - #installing "

        result=$?

        if (( result > 0 ))
        then
          rvm_error "There has been an error while trying to run the ree installer. Halting the installation."
          return $result
        fi

        chmod +x "$rvm_ruby_home"/bin/*

        "$rvm_scripts_path/rubygems" latest
        __rvm_irbrc
        __rvm_bin_script
        __rvm_post_install
      else

        __rvm_db "${rvm_ruby_interpreter}_${rvm_ruby_version}_repo_url" "rvm_ruby_url"

        if [[ -z "$rvm_ruby_url" ]] ; then
          rvm_error "rvm does not know the rvm repo url for '${rvm_ruby_interpreter}_${rvm_ruby_version}'"
          result=1

        else
          rvm_ruby_repo_url="$rvm_ruby_url"
          if (( ${rvm_make_flags_flag:=0} >  0 ))
          then
            __rvm_make_flags
          fi
          __rvm_install_source $*
        fi
      fi
    ;;

    rbx|rubinius)

      rvm_log "$rvm_ruby_string installing #dependencies "

      if ! __rvm_ensure_has_18_compat_ruby
      then
        rvm_log "No 1.8 compatible ruby found, cannot build rbx."
        return 1
      fi

      # TODO: use 'rvm gems load' here:
      unset CFLAGS LDFLAGS ARCHFLAGS # Important.

      unset GEM_HOME GEM_PATH MY_RUBY_HOME IRBRC

      __rvm_remove_rvm_from_path

      __rvm_conditionally_add_bin_path
      export PATH

      builtin hash -r

      if [[ -n "$(printf "${rvm_ruby_version:-""}" | awk '/^1\./')" ]] \
        && (( ${rvm_head_flag:=0} == 0 ))
      then
        rvm_log "$rvm_ruby_string #downloading ($rvm_ruby_package_file), this may take a while depending on your connection..."

        "$rvm_scripts_path/fetch" "$rvm_ruby_url"
        result=$?

        if (( result > 0 ))
        then
          rvm_error "There has been an error while trying to fetch the source. Halting the installation."
          exit $result
        fi
        __rvm_run "extract" \
          "gunzip < \"${rvm_archives_path}/$(basename $rvm_ruby_package_file)\" | tar xf - -C ${rvm_src_path}" --no-same-owner \
          "$rvm_ruby_string - #extracting"
        result=$?

        if (( result > 0 ))
        then
          rvm_error "There has been an error while trying to extract the source.  \nHalting the installation."
          exit $result
        fi

        # Remove the left over folder first.
        __rvm_rm_rf "${rvm_src_path}/$rvm_ruby_string"

        mv "${rvm_src_path}/rubinius-${rvm_ruby_version}" \
          "${rvm_src_path}/$rvm_ruby_string"
      else
        __rvm_db "rubinius_repo_url" "rvm_ruby_repo_url"
        #rvm_ruby_home="$rvm_rubies_path/$rvm_ruby_interpreter-$rvm_ruby_version"
        __rvm_fetch_from_github "rbx"
        result=$?

        if (( result > 0 ))
        then
          rvm_error "There has been an error while fetching the rbx git repo.  \nHalting the installation."
          exit $result
        fi
      fi

      builtin cd "${rvm_src_path}/$rvm_ruby_string"

      chmod +x ./configure

      __rvm_apply_patches
      result=$?

      if (( result > 0 ))
      then
        rvm_error "There has been an error while trying to apply patches to rubinius.  \nHalting the installation."
        return $result
      fi

      __rvm_db "${rvm_ruby_interpreter}_configure_flags" "db_configure_flags"

      export ruby="$(__rvm_18_compat_ruby)"

      rvm_configure_flags="${rvm_configure_flags:-"--skip-system"}"

      rvm_ruby_configure="$rvm_wrappers_path/$ruby/ruby ${rvm_configure_env:-""} ./configure --prefix=$rvm_ruby_home $db_configure_flags $rvm_configure_flags"
      message="$rvm_ruby_string - #configuring"

      if (( ${rvm_llvm_flag:=1} == 0 ))
      then # Explicitely disabled
        rvm_ruby_configure="$rvm_ruby_configure --disable-llvm"
      fi

      __rvm_run "configure" "$rvm_ruby_configure" "$message"
      result=$?

      if (( result > 0 ))
      then
        rvm_error "There has been an error while running '$rvm_ruby_configure'.  \nHalting the installation."
        exit $result
      fi

      if (( ${rvm_trace_flag:=0} == 1 ))
      then
        rvm_ruby_make="$rvm_wrappers_path/$ruby/rake install --trace"
        message="$rvm_ruby_string - #compiling (with --trace)"
      else
        rvm_ruby_make="$rvm_wrappers_path/$ruby/rake install"
        message="$rvm_ruby_string - #compiling"
      fi

      __rvm_run "rake" "$rvm_ruby_make" "$message"
      result=$?

      if (( result > 0 ))
      then
        rvm_error "There has been an error while running '$rvm_ruby_configure'.\nHalting the installation."
        exit $result
      fi ; unset ruby

      # Symlink rubinius wrappers
      ln -fs "$rvm_ruby_home/bin/rbx" "$rvm_ruby_home/bin/ruby"

      # Install IRB Wrapper on Rubinius.
      file_name="$rvm_ruby_home/bin/irb"

      rm -f "$file_name"

      printf '#!/usr/bin/env bash\n' > "$file_name"

      printf "exec '$rvm_ruby_home/bin/rbx' 'irb' \"\$@\"\n" >> "$file_name"

      [[ -x "$file_name" ]] || chmod +x "$file_name"

      # Install Gem Wrapper on Rubinius.
      file_name="$rvm_ruby_home/bin/gem"

      cp -f "$rvm_ruby_home/lib/bin/gem.rb" "$file_name"

      __rvm_inject_ruby_shebang "$file_name"

      [[ ! -x "$file_name" ]] || chmod +x "$file_name"

      unset file_name

      binaries=(erb ri rdoc)

      __rvm_post_install

      __rvm_irbrc

      __rvm_bin_script
    ;;

    jruby)

      if ! command -v java > /dev/null; then
        printf "java must be installed and in PATH in order to install JRuby."
        return 1
      fi

      if [[ "Darwin" = "$(uname)" ]] ; then
        java_version=$(java -version 2>&1  | awk -F'"' '/ version /{print $2}')
        case "$java_version" in
          1.5.*)
            printf "\n\nWARNING: A very outdated JAVA version is being used ($java_version), it is strongly recommended that you upgrade to the latest version.\n\n"
            ;;
          1.3.*|1.4.*)
            printf "\n\nERROR: Unsupported JAVA version $java_version. In order to install and use JRuby you must upgrade to the latest JAVA version.\n\n"
            exit 1
            ;;
        esac
      fi

      builtin cd "${rvm_src_path}"

      __rvm_fetch_ruby
      result=$?

      if (( result > 0 ))
      then
        rvm_error "There has been an error while trying to fetch the source.  \nHalting the installation."
        exit $result
      fi

      builtin cd "${rvm_src_path}/$rvm_ruby_string"

      if (( ${rvm_head_flag:=0} == 1 ))
      then
        __rvm_apply_patches

        __rvm_run "ant.dist" "ant dist" "$rvm_ruby_string - #ant dist"
      fi

      mkdir -p "$rvm_ruby_home/bin/"

      case "$rvm_ruby_version" in
        1.3|1.2)
          __rvm_run "nailgun" \
            "builtin cd \"${rvm_src_path}/$rvm_ruby_string/tool/nailgun\" &&  make $rvm_make_flags" \
            "Building Nailgun"
          ;;
        *)
          __rvm_run "nailgun" \
            "builtin cd \"${rvm_src_path}/$rvm_ruby_string/tool/nailgun\" && ${rvm_configure_env:-""} ./configure --prefix=$rvm_ruby_home && make $rvm_make_flags" \
            "Building Nailgun"
          ;;
      esac

      __rvm_rm_rf "$rvm_ruby_home"

      __rvm_run "install" \
        "/bin/cp -Rf ${rvm_src_path}/$rvm_ruby_string $rvm_ruby_home" "$rvm_ruby_string - #installing to $rvm_ruby_home"

      (
        builtin cd "$rvm_ruby_home/bin/"
        for binary in jirb jruby jgem ; do
          ln -fs "$binary" "${binary#j}"
        done ; unset binary
      )

      # -server is "a lot slower for short-lived scripts like rake tasks, and takes longer to load"
      #sed -e 's#^JAVA_VM=-client#JAVA_VM=-server#' $rvm_ruby_home/bin/jruby > $rvm_ruby_home/bin/jruby.new &&
      #  mv $rvm_ruby_home/bin/jruby.new $rvm_ruby_home/bin/jruby
      chmod +x "$rvm_ruby_home/bin/jruby"

      binaries=(jrubyc jirb_swing jirb jgem rdoc ri spec autospec testrb ast generate_yaml_index.rb)

      for binary in "${binaries[@]}" ; do
        __rvm_inject_gem_env "$rvm_ruby_home/bin/$binary"
      done

      __rvm_inject_ruby_shebang "$rvm_ruby_home/bin/rake"

      "$rvm_scripts_path/rubygems" latest

      __rvm_irbrc

      __rvm_bin_script

      __rvm_use

      __rvm_post_install

      # jruby ships with some built in gems, copy them in to place.
      if [[ -d "$rvm_ruby_home/lib/ruby/gems/1.8" ]]; then

        rvm_log "Copying across included gems"

        cp -R "$rvm_ruby_home/lib/ruby/gems/1.8/" "$rvm_ruby_gem_home/"
      fi

      "$rvm_ruby_home/bin/gem" install jruby-launcher
    ;;

    maglev)
      __rvm_ensure_has_18_compat_ruby

      rvm_log "Running MagLev prereqs checking script."

      "$rvm_scripts_path/maglev"
      result=$?

      if (( result > 0 ))
      then
        rvm_error "Prerequisite checks have failed. \nHalting the installation."
        exit $result
      fi

      builtin cd "${rvm_src_path}"

      if [[ ! -d "${rvm_src_path}/$rvm_ruby_string" ]] ||
        (( ${rvm_force_flag:=0} == 1 ))
      then
        __rvm_rm_rf "${rvm_src_path}/$rvm_ruby_string/"

        __rvm_fetch_ruby
        result=$?

        if (( result > 0 ))
        then
          rvm_error "There has been an error while trying to fetch the source.  \nHalting the installation."
          exit $result
        fi
      fi

      if (( ${rvm_head_flag:=0} == 1 ))
      then
        builtin cd "${rvm_src_path}/$rvm_ruby_string"

        rvm_gemstone_package_file="GemStone-$(\grep ^GEMSTONE version.txt | cut -f2 -d-).$(uname -sm | \tr ' ' '-')"

        rvm_gemstone_url="$maglev_url/${rvm_gemstone_package_file}.${rvm_archive_extension}"
      fi

      rvm_log "Downloading the GemStone package, this may take a while depending on your connection..."

      "$rvm_scripts_path/fetch" "$rvm_gemstone_url"
      result=$?

      if (( result > 0 ))
      then
        rvm_error "There has been an error while trying to fetch the GemStone package.\nHalting the installation."
        exit $result
      fi

      builtin cd "${rvm_src_path}"

      if [[ -s "$rvm_ruby_package_file" ]] ; then
        mv "$rvm_ruby_package_file" "${rvm_src_path}/$rvm_ruby_string"
      fi

      builtin cd "${rvm_src_path}/$rvm_ruby_string"

      __rvm_run "gemstone.extract" \
        "gunzip < \"${rvm_archives_path}/${rvm_gemstone_package_file}.${rvm_archive_extension}\" | tar xf - -C ${rvm_src_path}/$rvm_ruby_string" --no-same-owner
      result=$?

      if (( result > 0 ))
      then
        rvm_error "There has been an error while trying to extract the GemStone package. \nHalting the installation."
        exit $result
      fi

      chmod -R 777 "$rvm_gemstone_package_file" # for now. # WTF?! Crack.smoke!(:huff)

      ln -fs "$rvm_gemstone_package_file" "gemstone"

      __rvm_rm_rf $rvm_ruby_home

      __rvm_run "install" \
        "/bin/cp -Rf ${rvm_src_path}/$rvm_ruby_string $rvm_ruby_home" \
        "Installing maglev to $rvm_ruby_home"

      (
        builtin cd "$rvm_ruby_home/bin/"

        for binary in maglev-irb maglev-ruby maglev-gem
        do
          ln -fs "$binary" "${binary#maglev-}"
        done ; unset binary
      )

      binaries=(maglev-ruby maglev-irb maglev-gem)

      for binary in "${binaries[@]}"
      do
        __rvm_inject_gem_env "$rvm_ruby_home/bin/$binary"
      done

      builtin cd "$rvm_ruby_home"

      if (( ${rvm_head_flag:=0} == 1 ))
      then
        git submodule update --init

        "$rvm_ruby_home/bin/maglev" force-reload

        ln -sf maglev.demo.key-$(uname -sm | \tr ' ' '-') etc/maglev.demo.key
      fi

      #ln -fs "$rvm_ruby_home/$(echo $rvm_gemstone_package_file | awk -F'.' '{print $1}')" "$rvm_ruby_home/gemstone"

      compatible_ruby="$(__rvm_18_compat_ruby)"

      if [[ ! -e ${rvm_ruby_home}/etc/conf.d/maglev.conf ]]
      then
        rvm_log "Creating default 'maglev' repository."
        "$rvm_wrappers_path/$compatible_ruby/rake" "stone:create[maglev]" >/dev/null 2>&1
      fi

      rvm_log "Generating maglev HTML documentation"
      "$rvm_wrappers_path/$compatible_ruby/rake" rdoc >/dev/null 2>&1

      rvm_log "Generating smalltalk FFI."
      "$rvm_wrappers_path/$compatible_ruby/rake" stwrappers >/dev/null 2>&1

      unset compatible_ruby

      "$rvm_scripts_path/rubygems" latest

      __rvm_irbrc

      __rvm_bin_script

      __rvm_use
    ;;

    ironruby|ir)
      if ! command -v mono > /dev/null ; then
        printf "mono must be installed and in your path in order to install IronRuby." ; return 1
      fi

      if (( ${rvm_head_flag:=0} == 1 ))
      then
        mono_version="$(mono -V | head -n 1 | cut -d ' ' -f5)"

        if "$rvm_scripts_path/match" "$mono_version" "([0-9]+)\.([0-9]+)\.?([0-9]+)?" ; then

          mono_major_ver="$(echo "$mono_version" | cut -d '.' -f1)"

          mono_minor_ver="$(echo "$mono_version" | cut -d '.' -f2)"

          if [[ $mono_major_ver -lt 2 ]] \
            || ( [[ $mono_major_ver -eq 2 && $mono_minor_ver -lt 6 ]] ) ; then
            printf "Mono 2.6 (or greater) must be installed and in your path in order to build IronRuby from the repository."
            printf "Version detected: ${mono_version}"
            return 1
          fi
        else
          printf "Cannot recognize mono version."
          return 1
        fi

        __rvm_ensure_has_18_compat_ruby

        __rvm_fetch_ruby

        result=$?
        (( result == 0 )) || return $result

        builtin cd "${rvm_src_path}/$rvm_ruby_string"

        compatible_ruby="$(__rvm_18_compat_ruby)"

        "$rvm_wrappers_path/$compatible_ruby/gem" install pathname2 --no-rdoc --no-ri

        # MONO_LIB=/Library/Frameworks/Mono.framework/Versions/current/lib/
        rvm_ruby_make="$rvm_wrappers_path/$compatible_ruby/rake MERLIN_ROOT=\"${rvm_src_path}/$rvm_ruby_string/Merlin/Main\" compile mono=1 configuration=release --trace"
        __rvm_run "rake" "$rvm_ruby_make" "Building IronRuby..."
        unset compatible_ruby
        result=$?
        (( result == 0 )) || exit $result

        __rvm_rm_rf "$rvm_ruby_home"/*

        mkdir -p "$rvm_ruby_home/bin" "$rvm_ruby_home/lib" \
          "$rvm_ruby_home/lib/ruby" "$rvm_ruby_home/lib/IronRuby"

        cp -r "${rvm_src_path}/$rvm_ruby_string/Merlin/Main/Bin/mono_release"/* "$rvm_ruby_home/bin/"
        cp -r "${rvm_src_path}/$rvm_ruby_string/Merlin/Main/Languages/Ruby/Scripts/bin"/* "$rvm_ruby_home/bin/"
        cp -r "${rvm_src_path}/$rvm_ruby_string/Merlin/External.LCA_RESTRICTED/Languages/Ruby/redist-libs/ruby"/* "$rvm_ruby_home/lib/ruby"
        cp -r "${rvm_src_path}/$rvm_ruby_string/Merlin/Main/Languages/Ruby/Libs"/* "$rvm_ruby_home/lib/IronRuby"
      else
        rvm_log "Retrieving IronRuby"

        "$rvm_scripts_path/fetch" "$rvm_ruby_url" \
          "$rvm_ruby_package_file"
        result=$?
        if (( result > 0 ))
        then
          rvm_error "There has been an error while trying to fetch the source. \nHalting the installation."
          exit $result
        fi

        mkdir -p "${rvm_src_path}/$rvm_ruby_string" "$rvm_ruby_home"

        unzip -o  -d "${rvm_src_path}/$rvm_ruby_string" \
          "${rvm_archives_path}/${rvm_ruby_package_file}" >> \
          "${rvm_log_path}/$rvm_ruby_string/extract.log" 2>&1
        result=$?

        if (( result > 1 ))
        then
          rvm_error "There has been an error while trying to extract $rvm_ruby_package_file.\n${rvm_log_path}/$rvm_ruby_string/extract.log might have more details.\nHalting the installation."
          exit $result
        fi

        for dir in bin lib silverlight
        do
          cp -Rf "${rvm_src_path}/$rvm_ruby_string/$dir" "$rvm_ruby_home/$dir"
        done
      fi

      binaries=(gem irb rdoc rake ri ruby)

      for binary_name in "${binaries[@]}"
      do
        if [[ -s "$rvm_ruby_home/bin/$binary_name" ]]
        then
          tr -d '\r' < "$rvm_ruby_home/bin/$binary_name" > "$rvm_ruby_home/bin/$binary_name.new"

          #sed -e '1,1s=.*=#!'"/usr/bin/env ir=" "$rvm_ruby_home/bin/$binary_name" > "$rvm_ruby_home/bin/$binary_name.new"
          mv -f "$rvm_ruby_home/bin/$binary_name.new" "$rvm_ruby_home/bin/$binary_name"
          chmod +x "$rvm_ruby_home/bin/$binary_name"

        fi
      done ; unset binaries

      sed -e '1,1s=.*=#!'"/usr/bin/env bash=" "$rvm_ruby_home/bin/ir" \
        | \tr -d '\r' > "$rvm_ruby_home/bin/ir.new"

      mv -f "$rvm_ruby_home/bin/ir.new" "$rvm_ruby_home/bin/ir"

      chmod +x "$rvm_ruby_home/bin/ir"

      ln -fs "$rvm_ruby_home/bin/ir" "$rvm_ruby_home/bin/ruby"

      builtin hash -r

      __rvm_run "gems.install" \
        "PATH=\"$rvm_ruby_gem_home/bin:$rvm_ruby_global_gems_path/bin:$rvm_ruby_home/bin:$PATH\" GEM_HOME=\"$rvm_ruby_gem_home\" GEM_PATH=\"$rvm_ruby_gem_home:$rvm_ruby_global_gems_path\" $rvm_ruby_home/bin/gem install --no-rdoc --no-ri rake $rvm_gem_options" \
        "Installing $rvm_gem_name to $dir"
    ;;

    goruby)
      (( ${rvm_make_flags_flag:=0} == 0 )) || __rvm_make_flags

      unset GEM_HOME GEM_PATH MY_RUBY_HOME IRBRC

      __rvm_remove_rvm_from_path

      __rvm_conditionally_add_bin_path ; export PATH

      builtin hash -r

      rvm_ruby_home="$rvm_rubies_path/$rvm_ruby_interpreter"

      __rvm_fetch_from_github "ruby" "trunk"

      __rvm_apply_patches ; result=$?

      if [[ "$result" -gt 0 ]] ; then
        rvm_error "There has been an error while trying to apply patches to goruby.  \nHalting the installation."
        exit $result
      fi

      if [[ ! -s "${rvm_src_path}/$rvm_ruby_string/configure" ]]
      then
        if command -v autoconf &> /dev/null
        then
          __rvm_run "autoconf" "autoconf" "Running autoconf"
        else
          rvm_error "rvm expects autoconf to install this ruby interpreter, autoconf was not found in PATH. \
            \nHalting installation."
          exit $result
        fi
      fi

      if [[ -s ./Makefile && -z "$rvm_reconfigure_flag" ]]
      then
        if (( ${rvm_debug_flag:=0} > 0 ))
        then
          rvm_debug "Skipping configure step, Makefile exists so configure must have already been run."
        fi
      elif [[ -n "$rvm_ruby_configure" ]]
      then
        __rvm_run "configure" "$rvm_ruby_configure"
        result=$?

        if (( result > 0 ))
        then
          rvm_error "There has been an error while trying to configure the source.  \nHalting the installation."
          exit $result
        fi

      elif [[ -s ./configure ]]
      then
        local configure_command="${rvm_configure_env:-""} ./configure --prefix=$rvm_ruby_home $rvm_configure_flags"

        __rvm_run "configure" "$configure_command" \
          "Configuring $rvm_ruby_string using $rvm_configure_flags, this may take a while depending on your cpu(s)..."
        result=$?

        if (( result > 0 ))
        then
          rvm_error "There has been an error while trying to configure the source.  \nHalting the installation."
          exit $result
        fi

      else
        rvm_error "Skipping configure step, 'configure' script does not exist, did autoconf not run successfully?"
      fi

      rvm_ruby_make=${rvm_ruby_make:-"make"}

      __rvm_run "make" "$rvm_ruby_make golf $rvm_make_flags" \
        "Compiling $rvm_ruby_string, this may take a while depending on your cpu(s)..."
      result=$?

      if (( result > 0 ))
      then
        rvm_error "There has been an error while trying to run make.  \nHalting the installation."
        exit $result
      fi

      rvm_ruby_make_install=${rvm_ruby_make_install:-"make install"}

      __rvm_run "install" "$rvm_ruby_make_install" "Installing $rvm_ruby_string"
      result=$?

      if (( result > 0 ))
      then
        rvm_error "There has been an error while trying to run make install.  \nHalting the installation."
        exit $result
      fi

      rvm_log "Installation of $rvm_ruby_string is complete."

      export GEM_HOME="$rvm_ruby_gem_home"
      export GEM_PATH="$rvm_ruby_gem_path"

      "$rvm_scripts_path/rubygems" latest

      __rvm_bin_script

      __rvm_run "chmod.bin" "chmod +x $rvm_ruby_home/bin/*"

      __rvm_post_install

      rm $rvm_ruby_home/bin/ruby
      ln -s $rvm_ruby_home/bin/goruby $rvm_ruby_home/bin/ruby
      ;;

    ruby|kiji)

      __rvm_check_for_bison # && Run like hell...
      if (( $? > 0 ))
      then
        rvm_log "Bison required but not found. Halting."
        exit $result
      fi

      if (( ${rvm_make_flags_flag:=0} == 1 ))
      then
        __rvm_make_flags
      fi

      ( __rvm_install_source $* )
      result=$?
      ;;

    default)
      rvm_error "a ruby interpreter to install must be specified and not simply 'default'."
      ;;

    *)
      rvm_error "Either the ruby interpreter is unknown or there was an error!."
      ;;

  esac

  rvm_hook="after_install"
  source "$rvm_scripts_path/hook"

  if [[ -n "$ruby_options" ]]
  then
    RUBYOPT="$ruby_options"
    export RUBYOPT
  fi

  return ${result:-0}
}

__rvm_fetch_from_github()
{
  __rvm_rm_rf "${rvm_src_path}/$rvm_ruby_string"

  if [[ ! -d "${rvm_repos_path}/$rvm_ruby_string/.git" ]]
  then
    __rvm_rm_rf "${rvm_repos_path}/$rvm_ruby_string"

    builtin cd "$rvm_home"

    __rvm_run "$1.repo" \
      "git clone --depth 1 $rvm_ruby_repo_url ${rvm_repos_path}/$rvm_ruby_string" \
      "Cloning $rvm_ruby_repo_url"
    result=$?

    if (( result > 0 ))
    then
      rvm_ruby_repo_http_url="${rvm_ruby_repo_url//git:/http:}"

      rvm_log "Could not fetch $rvm_ruby_repo_url - trying $rvm_ruby_repo_http_url"

      __rvm_run "$1.repo" "git clone --depth 1 $rvm_ruby_repo_http_url ${rvm_repos_path}/$rvm_ruby_string" "Cloning $rvm_ruby_repo_http_url"
    fi
  else
    local branch="${rvm_ruby_repo_branch:-"master"}"

    builtin cd "${rvm_repos_path}/$rvm_ruby_string"

    __rvm_run "$1.repo" "git reset --hard HEAD ; git pull --rebase origin $branch" "Pulling from origin $branch"
  fi

  (
    remote="origin"

    cd "${rvm_repos_path}/$rvm_ruby_string"

    if [[ -z "$(git branch | awk "/$rvm_ruby_repo_branch$/")" ]]
    then
      git checkout -b "$rvm_ruby_repo_branch" \
        --track "$remote/$rvm_ruby_repo_branch" 2>/dev/null

    elif [[ -z "$(git branch | awk "/\* $rvm_ruby_repo_branch$/")" ]]
    then
      if ! git checkout $rvm_ruby_repo_branch 2>/dev/null
      then
        rvm_error "Branch $remote/$rvm_ruby_repo_branch not found."
      fi
    fi
  )

  __rvm_rm_rf "${rvm_src_path}/$rvm_ruby_string"

  __rvm_run "$1.copy" "\\cp -Rf \"${rvm_repos_path}/${rvm_ruby_string}/\" \"${rvm_src_path}/$rvm_ruby_string\"" "Copying from repo to source..."

  builtin cd "${rvm_src_path}/$rvm_ruby_string"

  return ${result:-0}
}

__rvm_fetch_ruby()
{
  if (( ${rvm_ruby_selected_flag:=0} == 0 ))
  then
    __rvm_select
  fi

  rvm_log "$rvm_ruby_string - #fetching "

  if (( ${rvm_head_flag:=0} == 0 )) &&
    [[ -z "${rvm_ruby_tag:-""}" && -z "${rvm_ruby_revision:-""}" ]]
  then
    rvm_ruby_package_name="${rvm_ruby_package_name:-"$rvm_ruby_string"}"

    rvm_ruby_package_file="${rvm_ruby_package_file:-"$rvm_ruby_package_name"}"

    if [[ "ruby" = "$rvm_ruby_interpreter" ]]
    then
      rvm_archive_extension="${rvm_archive_extension:-tar.bz2}"
    else
      rvm_archive_extension="${rvm_archive_extension:-tar.gz}"
    fi

    if [[ ! -s "${rvm_archives_path}/$rvm_ruby_package_file.$rvm_archive_extension" ]]
    then
      case "$rvm_ruby_interpreter" in
        ruby)
          rvm_ruby_url="$(__rvm_db "${rvm_ruby_interpreter}_${rvm_ruby_release_version}.${rvm_ruby_major_version}_url")/$rvm_ruby_package_file.$rvm_archive_extension"
          ;;
        ree)
          rvm_ruby_url="$(__rvm_db "${rvm_ruby_interpreter}_${rvm_ruby_version}_url")/${rvm_ruby_package_file}.${rvm_archive_extension}"
          ;;
        jruby)
          rvm_ruby_url="$(__rvm_db "${rvm_ruby_interpreter}_url")/${rvm_ruby_version}/${rvm_ruby_package_file}.${rvm_archive_extension}"
          ;;
        maglev)
          : # Should already be set from selector
          ;;
        *)
          rvm_ruby_url="$(__rvm_db "${rvm_ruby_interpreter}_url")/${rvm_ruby_package_file}.${rvm_archive_extension}"
          ;;
      esac

      rvm_log "$rvm_ruby_string - #downloading ${rvm_ruby_package_file}, this may take a while depending on your connection..."

      "$rvm_scripts_path/fetch" "${rvm_ruby_url}"
      result=$?

      if (( result > 0 ))
      then
        rvm_error "There has been an error while trying to fetch the source.  \nHalting the installation."
        return $result
      fi
    fi

    # Remove the directory if it is empty
    ( [[ ! -d "${rvm_src_path}/$rvm_ruby_string" ]] || rmdir "${rvm_src_path}/$rvm_ruby_string" 2>/dev/null ) || true

    if [[ ! -d "${rvm_src_path}/$rvm_ruby_string" ]] ||
      (( ${rvm_force_flag:=0} == 1 ))
    then
      # Especially when forced, we want to ensure the destination is missing.
      __rvm_rm_rf "${rvm_src_path}/${rvm_ruby_string}"

      mkdir -p "${rvm_tmp_path:-/tmp}/rvm_src_$$"

      case "$rvm_archive_extension" in
        tar.gz|tgz)
          __rvm_run "extract" "gunzip < \"${rvm_archives_path}/$rvm_ruby_package_file.$rvm_archive_extension\" | tar xf - -C ${rvm_tmp_path:-/tmp}/rvm_src_$$ --no-same-owner" "$rvm_ruby_string - #extracting $rvm_ruby_package_file to ${rvm_src_path}/$rvm_ruby_string"
          result=$?

          if (( result > 0 ))
          then
            rvm_error "There has been an error while trying to extract the source.  \nHalting the installation."
            return $result
          fi
          ;;
        zip)
          __rvm_run "extract" "unzip -q -o ${rvm_archives_path}/$rvm_ruby_package_file -d ${rvm_tmp_path:-/tmp}/rvm_src_$$"
          result=$?

          if (( result > 0 ))
          then
            rvm_error "There has been an error while trying to extract $rvm_ruby_package_file.  \nHalting the installation."
            return $result
          fi
          ;;
        tar.bz2)
          __rvm_run "extract" "bunzip2 < '${rvm_archives_path}/$rvm_ruby_package_file.$rvm_archive_extension' | tar xf - -C ${rvm_tmp_path:-/tmp}/rvm_src_$$" "$rvm_ruby_string - #extracting $rvm_ruby_package_file to ${rvm_src_path}/$rvm_ruby_string"
          result=$?

          if (( result > 0 ))
          then
            rvm_error "There has been an error while trying to extract the source.  \nHalting the installation."
            return $result
          fi
          ;;
        *)
          rvm_error "Unknown archive format extension '$rvm_archive_extension'.  \nHalting the installation."
          return 1
          ;;
      esac

      __rvm_rm_rf "${rvm_src_path}/$rvm_ruby_string"

      mv "${rvm_tmp_path:-/tmp}/rvm_src_$$/$(builtin cd ${rvm_tmp_path:-/tmp}/rvm_src_$$ ; ls)" \
        "${rvm_src_path}/$rvm_ruby_string"

      __rvm_rm_rf "${rvm_tmp_path:-/tmp}/rvm_src_$$"

      if [[ -n "${rvm_ruby_name:-""}" && -d "${rvm_src_path}/$(echo $rvm_ruby_string | sed -e 's/-n.*//')" ]] ; then
        mv "${rvm_src_path}/$(echo "$rvm_ruby_string" | sed -e 's/-n.*//')" "${rvm_src_path}/$rvm_ruby_string"
      fi

      rvm_log "$rvm_ruby_string - #extracted to ${rvm_src_path}/$rvm_ruby_string"
    else
      rvm_log "$rvm_ruby_string - #extracted to ${rvm_src_path}/$rvm_ruby_string (already extracted)"
    fi

    return 0
  else # -head
    mkdir -p "${rvm_repos_path}"

    [[ -n "${rvm_ruby_url:-""}" ]] || rvm_ruby_url="$rvm_ruby_repo_url"

    if echo "$rvm_ruby_url" | grep 'git' >/dev/null 2>&1
    then # Using a  git url.
      case "$rvm_ruby_interpreter" in
        ruby)
          # Determine Branch
          if [[ -z "${rvm_ruby_repo_branch:-""}" ]]
            then
            if [[ -n "${rvm_ruby_major_version:-""}" ]]
            then
              if [[ -n "${rvm_ruby_minor_version:-""}" ]]
              then
                rvm_ruby_repo_branch="ruby_1_${rvm_ruby_major_version}_${rvm_ruby_minor_version}"
              else
                rvm_ruby_repo_branch="ruby_1_${rvm_ruby_major_version}"
              fi
            else
              rvm_ruby_repo_branch="trunk" # NOTE: Ruby Core team maps 'trunk' as HEAD
            fi
          fi
          ;;

        ree|jruby|maglev|*)
          rvm_ruby_repo_branch="${rvm_ruby_repo_branch:-"master"}"
          ;;

      esac

      # Clone if repository does not yet exist locally
      if [[ ! -d "${rvm_repos_path}/$rvm_ruby_string/.git" ]]
      then
        __rvm_rm_rf "${rvm_repos_path}/$rvm_ruby_string"

        rvm_ruby_repo_http_url="${rvm_ruby_repo_url//git:/https:}"

        rvm_log "Cloning from $rvm_ruby_repo_url, this may take a while depending on your connection..."

        git clone --depth 1 "$rvm_ruby_repo_url" \
          "${rvm_repos_path}/$rvm_ruby_string"
        result=$?

        if (( result > 0 ))
        then
          rvm_log "cloning from $rvm_ruby_repo_url failed, now attempting to clone from $rvm_ruby_repo_http_url, this may take a while depending on your connection..."

          git clone "$rvm_ruby_repo_http_url" \
            "${rvm_repos_path}/$rvm_ruby_string"
          result=$?

          if (( result > 0 ))
          then
            rvm_error "There has been an error while trying to fetch the repository.  \nHalting the installation."
            return $result
          fi
        fi

      fi

      # Use the selected branch.
      (
        cd "${rvm_repos_path}/$rvm_ruby_string"

        remote="${remote:-origin}"
        branch=$(git symbolic-ref -q HEAD 2>/dev/null)
        branch=${branch##refs/heads/}

        git reset --hard HEAD # Ensure we are in a good state.

        git fetch "${remote}" # Download the latest updates locally.

        if [[ "$branch" == "${rvm_ruby_repo_branch}" ]]
        then
          git pull "${remote}" "${rvm_ruby_repo_branch}"
        else
          case "$(git branch 2>/dev/null)" in
            (*[[:space:]]${rvm_ruby_repo_branch}*)
              # Not already on the desired branch, but it does exist locally.
              git checkout "${rvm_ruby_repo_branch}" # Branch is local, checkout
              git pull "$remote" "${rvm_ruby_repo_branch}" # Bring local to latest
              ;;
            *)
              # Desired branch does not exist locally.
              if ! git checkout -t "${remote}/${rvm_ruby_repo_branch}"
              then
                result=$?
                rvm_error "Branch $remote/$rvm_ruby_repo_branch not found."
                return $result
              fi
              ;;
          esac
        fi
        return $?
      )
      result=$?

      if (( result > 0 ))
      then
        rvm_error "There has been an error while checking out branch ${rvm_ruby_repo_branch}.  \nHalting the installation."
        return $result
      fi

      # If a revision was specified, check it out.
      if [[ -n "$rvm_ruby_revision" ]]
      then
        (
          cd "${rvm_repos_path}/$rvm_ruby_string"

          if [[ -z "${rvm_ruby_sha:-""}" ]]
          then
            [[ "$rvm_ruby_revision" != "head" ]] || rvm_ruby_revision="master"
            git checkout "$rvm_ruby_revision"
          else
            git checkout ${rvm_ruby_sha/#s/}
          fi
        )
        result=$?

        if (( result > 0 ))
        then
          rvm_error "There has been an error while trying to checkout the source branch.\nHalting the installation."
          return $result
        fi
      fi

    else
      if [[ -n "${rvm_ruby_tag:-""}" ]]
      then
        # TODO: Check if tag v is valid
        true "${rvm_ruby_url:="$rvm_ruby_repo_url/tags/$(echo "$rvm_ruby_tag" | sed 's/^t//')"}"

      elif [[ -z "${rvm_ruby_version:-""}" && ${rvm_head_flag:-0} -eq 1 ]]
      then
        true "${rvm_ruby_url:="$rvm_ruby_repo_url/trunk"}"

      elif [[  "${rvm_ruby_major_version:-""}" = "9" ]]
      then
        if [[ -z "${rvm_ruby_minor_version:-""}" || "${rvm_ruby_minor_version:-""}" = 3 ]]
        then
          true "${rvm_ruby_url:="$rvm_ruby_repo_url/trunk"}"

        else
          true "${rvm_ruby_url:="$rvm_ruby_repo_url/branches/ruby_${rvm_ruby_release_version}_${rvm_ruby_major_version}_${rvm_ruby_minor_version}"}"
        fi
      elif [[ -z "${rvm_ruby_minor_version:-""}" ||
        "${rvm_ruby_major_version:-""}.${rvm_ruby_minor_version:-""}" = "8.8" ]]
      then
        true "${rvm_ruby_url:="$rvm_ruby_repo_url/branches/ruby_${rvm_ruby_release_version}_${rvm_ruby_major_version}"}"
      else
        "${rvm_ruby_url:="$rvm_ruby_repo_url/branches/ruby_${rvm_ruby_release_version}_${rvm_ruby_major_version}_${rvm_ruby_minor_version}"}"
      fi

      rvm_rev=""

      [[ -z "${rvm_ruby_revision:-""}" ]] || rvm_rev="-$rvm_ruby_revision"

      (
        builtin cd "${rvm_repos_path}/$rvm_ruby_string"

        if [[ -d "${rvm_repos_path}/$rvm_ruby_string/.svn" ]]
        then
          rvm_log "Updating ruby from $rvm_ruby_url"

          __rvm_run "svn.switch" "svn switch $rvm_ruby_url"

          __rvm_run "svn.update" "svn update"

          if [[ -n "${rvm_rev:-""}" ]]
          then
            rvm_log "Checking out revision ${rvm_rev/-r/-r } from $rvm_ruby_url"

            __rvm_run "svn.checkout" "svn update -q ${rvm_rev/-r/-r }"
          fi
        else
          __rvm_rm_rf "${rvm_repos_path}/$rvm_ruby_string"

          __rvm_run "svn.checkout" \
            "svn checkout -q ${rvm_rev/-r/-r } $rvm_ruby_url ${rvm_repos_path}/$rvm_ruby_string" \
            "Downloading source from ${rvm_ruby_url}."
        fi
      )
      result=$?

      if (( result > 0 ))
      then
        rvm_error "There has been an error while trying to fetch / update the source.  \nHalting the installation."
        return $result
      fi
    fi

    rvm_log "Copying from repo to src path..."

    __rvm_rm_rf "${rvm_src_path}/$rvm_ruby_string"

    cp -R "${rvm_repos_path}/$rvm_ruby_string" \
      "${rvm_src_path}/$rvm_ruby_string"
  fi

  return ${result:-0}
}

__rvm_check_default()
{
  local default_ruby_interpreter current_ruby_interpreter

  default_ruby_interpreter="$(rvm alias show default 2>/dev/null \
    | awk -F"${rvm_gemset_separator:-"@"}" '{print $1}')"

  current_ruby_interpreter="$(echo "$rvm_ruby_string" \
    | awk -F"${rvm_gemset_separator:-"@"}" '{print $1}')"

  if [[ -n "$current_ruby_interpreter" &&
        "$current_ruby_interpreter" = "$default_ruby_interpreter" ]]
  then
    __rvm_run_with_env 'default.restore' 'system' \
      'rvm use system --default' 'Removing default ruby interpreter'
  fi

  return $?
}

__rvm_uninstall_ruby()
{
  local dir

  if (( ${rvm_ruby_selected_flag:=0} == 0 ))
  then
    __rvm_select
  fi

  if [[ -n "${rvm_ruby_string:-""}" ]]
  then
    for dir in "$rvm_rubies_path"
    do
      if [[ -d "$dir/$rvm_ruby_string" ]]
      then
        rvm_log "Removing $dir/$rvm_ruby_string..."

        __rvm_rm_rf "$dir/$rvm_ruby_string"
      else
        rvm_log "$dir/$rvm_ruby_string has already been removed."
      fi

      if [[ -e "${rvm_bin_path}/$rvm_ruby_string" ]]
      then
        rm -f "${rvm_bin_path}/$rvm_ruby_string"
      fi
    done

    __rvm_remove_install_record "$rvm_ruby_string"

    __rvm_remove_gemsets

    __rvm_check_default
  else
    rvm_error "Cannot uninstall unknown package '$rvm_ruby_string'"
  fi

  unset rvm_uninstall_flag

  return 0
}

__rvm_remove_ruby()
{
  local dir

  if (( ${rvm_ruby_selected_flag:=0} == 0 ))
  then
    __rvm_select
  fi

  if [[ -n "${rvm_ruby_string:-""}" ]]
  then
    for dir in "${rvm_src_path}" "${rvm_rubies_path}"
    do
      if [[ -d "$dir/$rvm_ruby_string" ]]
      then
        rvm_log "Removing $dir/$rvm_ruby_string..."
        __rvm_rm_rf "$dir/$rvm_ruby_string"
      else
        rvm_log "it seems that $dir/$rvm_ruby_string is already non existent."
      fi

      [[ ! -e "${rvm_bin_path}/$rvm_ruby_string" ]] ||
        rm -f "${rvm_bin_path}/$rvm_ruby_string"

      __rvm_check_default

    done

    __rvm_remove_install_record "$rvm_ruby_string"
    __rvm_remove_gemsets
    __rvm_remove_archives
    __rvm_remove_aliases
    __rvm_remove_wrappers
    __rvm_remove_environments
    __rvm_remove_binaries

  else

    rvm_error "Cannot remove unknown package '$rvm_ruby_string'"

    return 1

  fi

  unset rvm_remove_flag

  return 0
}

__rvm_remove_gemsets()
{
  local gemset gemsets

  if (( ${rvm_gems_flag:=0} == 1 ))
  then
    rvm_log "Removing $rvm_ruby_string gemsets..."

    gemsets=( $(find "${rvm_gems_path:-"$rvm_path/gems"}" "${name_opt}" "${rvm_ruby_string}*" -maxdepth 1 -type d))

    for gemset in "${gemsets[@]}"
    do
      [[ ! -d "$gemset" ]] || __rvm_rm_rf "$gemset"
    done
  fi
}

__rvm_remove_wrappers()
{
  rvm_log "Removing $rvm_ruby_string wrappers..."

  local wrapper wrappers

  wrappers=($(find "$rvm_wrappers_path" -maxdepth 1 -mindepth 1 -type d "${name_opt}" "*$rvm_ruby_string*" 2>/dev/null))

  for wrapper in "${wrappers[@]}"
  do
    __rvm_rm_rf "$wrapper"
  done

  return 0
}

__rvm_remove_environments()
{
  rvm_log "Removing $rvm_ruby_string environments..."

  local environments environment

  environments=($(find "$rvm_environments_path" -maxdepth 1 -mindepth 1 -type f "${name_opt}" "*$rvm_ruby_string*" ))

  for environment in "${environments[@]}"
  do
    [[ ! -e "$environment" ]] || __rvm_rm_rf "$environment"
  done

  return 0
}

__rvm_remove_aliases()
{
  rvm_log "Removing $rvm_ruby_string aliases..."

  local alias_name aliases

  aliases=($(awk '/'$rvm_ruby_string'/' "$rvm_config_path/alias" | sed 's/=.*//'))

  for alias_name in "${aliases[@]}"
  do
    # Remove from alias key-value store
    "$rvm_scripts_path/alias" delete "$alias_name" >/dev/null 2>&1
  done
}

__rvm_remove_archives()
{
  if (( ${rvm_archive_flag:=0} == 1 ))
  then
    rvm_log "Removing $rvm_ruby_string archives..."
    rm -f "${rvm_archives_path}/${rvm_ruby_package_file}.${rvm_archive_extension}"
  fi
}

__rvm_remove_binaries()
{
  rvm_log "Removing $rvm_ruby_string binaries..."

  # Iterate over all binaries and check for symlinked wrappers etc.
  local binary_name binaries full_binary_path

  binaries=($(find "${rvm_bin_path}" -maxdepth 1 -mindepth 1 "${name_opt}" "*$rvm_ruby_string*" ))

  for full_binary_path in "${binaries[@]}"
  do
    if [[ -L "$full_binary_path" ]] &&
      "$rvm_scripts_path/match" "$(readlink "$full_binary_path")" "$rvm_ruby_string"
    then
      rm -f "$full_binary_path"
    fi
  done ; unset binaries

  return 0
}

__rvm_post_install()
{
  local rvm_ruby_aliases ruby_alias binary

  if [[ "$rvm_ruby_interpreter" != "jruby" ]]
  then
    (( ${#binaries[@]} > 0 )) || binaries=(gem irb erb ri rdoc testrb rake)

    rvm_log "$rvm_ruby_string - adjusting #shebangs for (${binaries[@]})."

    for binary in "${binaries[@]}"
    do
      if [[ -e "$rvm_ruby_home/bin/$binary" ||
        -e "${rvm_src_path}/$rvm_ruby_string/bin/$binary" ]]
      then
        if [[ "${rvm_src_path}/$rvm_ruby_string" != "$rvm_ruby_home" &&
          -f "${rvm_src_path}/$rvm_ruby_string/bin/$binary" ]]
        then
          cp -f "${rvm_src_path}/$rvm_ruby_string/bin/$binary" "$rvm_ruby_home/bin/$binary"
        elif [[ -f "$rvm_ruby_gem_home/bin/$binary" ]]
        then
          cp -f "$rvm_ruby_gem_home/bin/$binary" "$rvm_ruby_home/bin/$binary"
        fi

        __rvm_inject_gem_env "$rvm_ruby_home/bin/$binary"

        __rvm_inject_ruby_shebang "$rvm_ruby_home/bin/$binary"

        chmod +x "$rvm_ruby_home/bin/$binary"
      fi
    done

    binaries=(gem irb erb ri rdoc testrb rake)
  fi

  # Import the initial gemsets.
  __rvm_run_with_env "gemsets.initial" "$rvm_ruby_string" \
    "'$rvm_scripts_path/gemsets' initial" \
    "$rvm_ruby_string - #importing default gemsets ($rvm_gemsets_path/)"

  __rvm_irbrc

  __rvm_generate_default_docs

  if [[ -n "$rvm_ruby_aliases" ]]
  then
    rvm_log "Setting up aliases for $rvm_ruby_string"

    while read -r ruby_alias
    do
      rvm_log "Aliasing $rvm_ruby_string to $ruby_alias"

      "$rvm_scripts_path/alias" delete "$ruby_alias" > /dev/null 2>&1

      "$rvm_scripts_path/alias" create "$ruby_alias" "$rvm_ruby_string" > /dev/null 2>&1
    done < <(printf "$rvm_ruby_string" | \tr ' ' '\n' | sort -u)
  fi
}

__rvm_generate_default_docs()
{
  if [[ "$rvm_docs_flag" = "1" && "$rvm_ruby_interpreter" != "macruby" ]]
  then
    __rvm_run_with_env "docs.generate" "$rvm_ruby_string" \
      "rvm docs generate-ri" "Attempting to generate ri documentation..."
  fi
}

__rvm_inject_ruby_shebang()
{
  local actual_file

  __rvm_actual_file $1

  if [[ -f "$actual_file" ]]
  then
    sed -e '1,1s=.*=#!'"/usr/bin/env ruby=" ${actual_file} > "${actual_file}.new"
    mv "${actual_file}.new" "${actual_file}" ; chmod +x "$actual_file"
  fi
}

__rvm_inject_gem_env()
{
  local actual_file string

  __rvm_actual_file $1

  if [[ -s "$actual_file" ]]
  then
    if [[ -n "$(head -n 1 "$actual_file" | awk '/[j]*ruby/')" ]]
    then
      string="ENV['GEM_HOME']=ENV['GEM_HOME'] || '$rvm_ruby_gem_home'\nENV['GEM_PATH']=ENV['GEM_PATH'] || '$rvm_ruby_gem_path'\nENV['PATH']='$rvm_ruby_gem_home/bin:$rvm_ruby_global_gems_path/bin:$rvm_ruby_home/bin:' + ENV['PATH']\n"

    elif [[ -n "$(head -n 1 "$actual_file" | awk '/bash/')" ]]
    then
      string="GEM_HOME=\${GEM_HOME:-'$rvm_ruby_gem_home'}\nGEM_PATH=\${GEM_PATH:-'$rvm_ruby_gem_home:$rvm_ruby_global_gems_path'}\nPATH=$rvm_ruby_gem_home/bin:$rvm_ruby_global_gems_path/bin:$rvm_ruby_home/bin:\$PATH\n"
    fi

    if [[ -n "$string" ]]
    then
      awk "NR==2 {print \"$string\"} {print}" "$actual_file" \
        > "$actual_file.new"
      mv $actual_file.new $actual_file
      chmod +x "$actual_file"
    fi
  fi

  return 0
}

__rvm_actual_file()
{
  if [[ -L "$1" ]]
  then # If the file is a symlink,
    actual_file="$(readlink $1)" # read the link target so we can preserve it.
  else
    actual_file="$1"
  fi

  return 0
}

__rvm_manage_rubies()
{
  local manage_result bin_line

  manage_result=0

  rvm_gemset_name=""
  rvm_ruby_selected_flag=0

  rvm_ruby_gem_home="${rvm_ruby_gem_home:-""//${rvm_gemset_separator:-"@"}*}"
  rvm_ruby_string="${rvm_ruby_string:-""//${rvm_gemset_separator:-"@"}*}"

  # TODO: See if this can work, currently errors out on 'cannot find i386' libs.
  # __rvm_setup_compile_environment

  # Given list of ruby strings.
  if [[ -n "${rubies_string:-""}" ]]
  then
    rubies=(${rubies_string//,/ })

    for rvm_ruby_string in "${rubies[@]}"
    do
      current_ruby_string="$rvm_ruby_string"

      rvm_hook="before_install"
      source "$rvm_scripts_path/hook"

      eval "__rvm_${action}_ruby"
      result="$?"

      (( result == 0 || manage_result > 1 )) || manage_result="$result"

      if (( result == 0 )) && [[ "$action" = "install" ]]
      then
        __rvm_record_install "$current_ruby_string"
      fi

      unset current_ruby_string

      __rvm_unset_ruby_variables

      rvm_hook="after_install"
      source "$rvm_scripts_path/hook"
    done
  else # all
    if [[ "$action" != "install" && "$action" != "remove" &&
      "$action" != "uninstall" ]]
  then
    local ruby_string

    while read -r ruby_string
    do # Keep this on second line damnit!

      if [[ -x "$ruby_string" ]]
      then
        rvm_ruby_string="$ruby_string"

        eval "__rvm_${action}_ruby"
        result="$?"

        (( result == 0 || manage_result > 0 )) || manage_result="$result"

        # record as current_manage_string to prevent it being overridden.
        if (( result == 0 )) && [[ "$action" = "install" ]]
        then
          __rvm_record_install "$ruby_string"
        fi

        __rvm_unset_ruby_variables
      fi
    done < <(builtin cd "$rvm_rubies_path" ; \
      find . -maxdepth 1 -mindepth 1 -type d 2> /dev/null | sed -e 's#./##g')

  else
    rvm_warn 'Really? '"$action"' all? See "rvm list known" and limit the selection to something more sane please :)'
  fi
fi

# TODO: This should return the exit status of the command that got called.
return $manage_result
}

args=($*)
action="${args[0]:-""}"
rubies_string="${args[1]:-""}"
args="$(echo ${args[@]:2}) " # Strip trailing / leading / extra spacing.
binaries=()

__rvm_manage_rubies

exit $?

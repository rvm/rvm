#!/usr/bin/env bash

original_ruby_version=${rvm_ruby_version:-""}
original_ruby_string=${rvm_ruby_string:-""}

source "$rvm_path/scripts/base"
source "$rvm_path/scripts/patches"

unset RUBYLIB RUBYOPT # Sanity check.

__rvm_check_for_clang()
{
  if [[ -n "${rvm_clang_flag:-""}" ]] && ! command -v clang >/dev/null ; then
    "$rvm_path/scripts/log" "fail" "\nYou passed the --clang option and clang is not in your path. \nPlease try again or do not use --clang.\n"
    return 1
  fi
}

# Checks for bison, returns zero iff it is found
__rvm_check_for_bison()
{
  if [[ ${rvm_head_flag:-0} -gt 0 ]]; then
    command -v bison > /dev/null
    result=$?
    if [[ $result -gt 0 ]] ; then
      "$rvm_path/scripts/log" "fail" \
        "\nbison is not available in your path. \nPlease ensure bison is installed before compiling from head.\n"
    fi
  fi

  return ${result:-0}
}

# Emits a number of patches to STDOUT, each on a new name
# Expands patchsets etc.
__rvm_current_patch_names()
{
  # TODO: Lookup default patches on rvm_ruby_string heirarchy.
  local separator patches level name

  separator="%"
  patches="${rvm_patch_names:-""} default"

  for patch_name in $(echo ${patches//,/ }); do

    level=1
    name="$patch_name"

    if echo "$name" | grep -q "$separator"; then
      level="${name/*${separator}/}"
      name="${name//${separator}*/}"
    fi

    local expanded_name="$(__rvm_expand_patch_name "$name")"

    echo "${expanded_name}${separator}${level}"

  done

  return 0
}

__rvm_apply_patches()
{
  local patches patch_name patch_level_separator patch_fuzziness patch_level source_directory full_patch_path

  result=0
  patch_level_separator="%"
  patch_fuzziness="25"
  patch_level=1

  source_directory="${1:-""}"

  if [[ -z "$source_directory" ]] ; then
    source_directory="${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"
  fi

  (
    builtin cd "$source_directory"

    patches=($(__rvm_current_patch_names))

    for patch_name in "${patches[@]}" ; do

      # If set, extract the patch level from the patch name.
      patch_level=1

      if echo "$patch_name" | \grep -q "$patch_level_separator"; then
        patch_level=${patch_name//*${patch_level_separator}/}
        patch_name="${patch_name//${patch_level_separator}*/}"
      fi

      full_patch_path="$(__rvm_lookup_full_patch_path "$patch_name")"

      # Expand paths, and for those we found we then apply the patches.
      if [[ -n "${full_patch_path:-""}" ]]; then

        if [[ -f "$full_patch_path" ]] ; then

          __rvm_run "patch.apply.${patch_name/*\/}" \
            "patch -F$patch_fuzziness -p$patch_level -f <\"$full_patch_path\"" \
            "Applying patch '$patch_name' (located at $full_patch_path)"

          [[ $? -gt 0 ]] && result=1 # Detect failed patches
        fi

      else
        "$rvm_path/scripts/log" "warn" \
          "Patch '$patch_name' not found."
        result=1
      fi
    done
  )

  return ${result:-0}
}

__rvm_install_source()
{
  local directory configure_parameters db_configure_flags

  [[ ${rvm_ruby_selected_flag:-0} -eq 0 ]] && __rvm_select

  case ${rvm_ruby_string:-""} in
    ruby-head|1.9.*-head) __rvm_ensure_has_18_compat_ruby || return 1 ;;
  esac

  "$rvm_path/scripts/log" "info" \
    "Installing Ruby from source to: $rvm_ruby_home, this may take a while depending on your cpu(s)...\n"

  builtin cd "${rvm_src_path:-"$rvm_path/src"}"

  if [[ ${rvm_force_flag:-0} -eq 1 ]] ; then

    for directory in "$rvm_ruby_home" "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string" ; do

      if [[ -d "$directory" ]] ; then
        rm -rf "$directory"
      fi

    done
  fi

  result=0

  __rvm_fetch_ruby
  result=$?

  if [[ "$result" -gt 0 ]] ; then
    "$rvm_path/scripts/log" "error" \
      "There has been an error fetching the ruby interpreter. Halting the installation."
    return $result
  fi

  builtin cd "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"

  result=$? ; if [[ "$result" -gt 0 ]] ; then
    "$rvm_path/scripts/log" "error" \
      "Source directory is missing.  Did the download or extraction fail?  Halting the installation."
    return $result
  fi

  if [[ -d "${rvm_path}/usr" ]] ; then
    export PATH="${rvm_path}/usr/bin:${PATH}"

    builtin hash -r
  fi

  if [[ ${rvm_static_flag:-0} -eq 1 ]]; then

    if [[ -s "ext/Setup" ]]; then
      echo 'option nodynamic' >> ext/Setup
      "$rvm_path/scripts/log" "info" "Setting option nodynamic (static)."
    else
      "$rvm_path/scripts/log" "info" "
      You asked for static Ruby compilation however the file ext/Setup
      appears to be missing from the source directory
      ${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string
      please investigate this, continuing installation regardless.
      "
    fi

  fi

  __rvm_apply_patches
  result="$?"

  if [[ $result -gt 0 ]]; then
    "$rvm_path/scripts/log" "fail" \
      "There has been an error applying the specified patches. Halting the installation."
    return $result
  fi

  if [[ -z "${rvm_ruby_configure:-""}" \
    && ! -s "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/configure" ]] ; then

    if command -v autoconf > /dev/null ; then

      __rvm_run "autoconf" "autoconf" "Running autoconf"

    else
      "$rvm_path/scripts/log" "fail" \
        "rvm requires autoconf to install the selected ruby interpreter however autoconf was not found in the PATH."
      return 1
    fi
  fi

  if [[ -n "${rvm_ruby_configure:-""}" ]] ; then

    __rvm_run "configure" "$rvm_ruby_configure"
    result=$?

    if [[ $result -gt 0 ]] ; then
      "$rvm_path/scripts/log" "error" \
        "There has been an error while configuring. Halting the installation."
      return $result
    fi

  elif [[ -s ./configure ]] ; then

    # REE stores configure flags differently for head vs. the distributed release.
    if [[ "ree" != "${rvm_ruby_interpreter:-""}" ]]; then
      __rvm_db "${rvm_ruby_interpreter}_configure_flags" "db_configure_flags"
    fi

    # On 1.9.2, we manually set the --with-baseruby option
    # to point to an expanded path.
    if [[ "${rvm_ruby_string:-""}" = "ruby-1.9.2-head" ]] ; then

      local compatible_baseruby="$rvm_path/wrappers/$(__rvm_18_compat_ruby)/ruby"

      if [[ -x "$compatible_baseruby" ]] ; then
        configure_parameters="--with-baseruby=$compatible_baseruby"
      fi
    fi

    local configure_command="${rvm_configure_env:-""} ./configure --prefix=$rvm_ruby_home ${db_configure_flags:-""} ${rvm_configure_flags:-""} ${configure_parameters:-""}"

    __rvm_run "configure" "$configure_command" "$rvm_ruby_string - #configuring "
    result=$?

    if [[ $result -gt 0 ]] ; then
      "$rvm_path/scripts/log" "error" \
        "There has been an error while running configure. Halting the installation."
      return $result
    fi

  else
    "$rvm_path/scripts/log" "error" \
      "Skipping configure step, 'configure' does not exist, did autoconf not run successfully?"
  fi

  rvm_ruby_make=${rvm_ruby_make:-"make"}

  __rvm_run "make" "$rvm_ruby_make ${rvm_make_flags:-""}" "$rvm_ruby_string - #compiling "
  result=$?

  if [[ $result -gt 0 ]] ; then
    "$rvm_path/scripts/log" "error" \
      "There has been an error while running make. Halting the installation."
    return $result
  fi

  if [[ -d .ext/rdoc ]] ; then
    rm -rf .ext/rdoc
  fi

  rvm_ruby_make_install=${rvm_ruby_make_install:-"make install"}

  __rvm_run "install" "$rvm_ruby_make_install" "$rvm_ruby_string - #installing "
  result=$?

  if [[ $result -gt 0 ]] ; then
    "$rvm_path/scripts/log" "error" \
      "There has been an error while running make install. Halting the installation."
    return $result
  fi

  export GEM_HOME="$rvm_ruby_gem_home"
  export GEM_PATH="$rvm_ruby_gem_path"

  __rvm_rubygems_setup
  result=$?

  __rvm_bin_script

  __rvm_run "chmod.bin" "chmod +x $rvm_ruby_home/bin/*"

  __rvm_post_install
  result=$?

  "$rvm_path/scripts/log" "info" \
    "Install of $rvm_ruby_string - #complete "

  return ${result:-0}
}

__rvm_install_ruby()
{
  if [[ ${rvm_ruby_selected_flag:-0} -eq 0 ]] ; then __rvm_select ; fi

  if [[ -n "${RUBYOPT:-""}" ]] ; then ruby_options="$RUBYOPT" ; fi

  unset RUBYOPT

  # Check for clang if the flag is set
  __rvm_check_for_clang
  result=$?

  [[ $result -gt 0 ]] && return $result

  case "$rvm_ruby_interpreter" in
    macruby)
      if [[ "Darwin" = "$(uname)" ]] ; then

        if [[ ${rvm_head_flag:-0} -eq 1 ]] ; then

          if [[ -n "$rvm_llvm_flag" ]] ; then
            "$rvm_path/scripts/package" llvm install
          fi

          macruby_path="/usr/local/bin"
          # TODO: configure & make variables should be set here.
          rvm_ruby_configure=" true "
          rvm_ruby_make="rake"
          rvm_ruby_make_install="$rvm_path/bin/rvmsudo rake install"

          __rvm_db "${rvm_ruby_interpreter}_repo_url" "rvm_ruby_url"

          rvm_ruby_repo_url=$rvm_ruby_url

          __rvm_install_source $*
          result=$?

          if [[ "$result" -gt 0 ]] ; then
            "$rvm_path/scripts/log" "error" \
              "There has been an error while trying to install from source. \
            \nHalting the installation."
            return $result
          fi

        elif [[ "nightly" = "$rvm_ruby_version" ]] ; then
          __rvm_db "macruby_nightly_version" "macruby_nightly_version"
          macruby_path="/Library/Frameworks/MacRuby.framework/Versions/${macruby_nightly_version}/usr/bin"
          unset macruby_nightly_version
          # TODO: Separated nightly from head.

          "$rvm_path/scripts/log" "info" "Retrieving the latest nightly macruby build..."

          "$rvm_path/scripts/fetch" "$rvm_ruby_url"
          result=$?
          if [[ $result -gt 0 ]] ; then
            "$rvm_path/scripts/log" "error" \
              "There has been an error while trying to fetch the source. \
              \nHalting the installation."
            return $result
          fi

          mv "${rvm_archives_path:-"$rvm_path/archives"}/macruby_nightly-latest.pkg" \
            "${rvm_archives_path:-"$rvm_path/archives"}/macruby_nightly.pkg"

          __rvm_run "macruby/extract" \
            "sudo /usr/sbin/installer -pkg '${rvm_archives_path:-"$rvm_path/archives"}/macruby_nightly.pkg' -target '/'"

          mkdir -p "$rvm_ruby_home/bin"

        else
          macruby_path="/Library/Frameworks/MacRuby.framework/Versions/${rvm_ruby_version}/usr/bin"

          # TODO: Separated nightly from head.
          "$rvm_path/scripts/log" "info" "Retrieving MacRuby ${rvm_ruby_version} ..."

          "$rvm_path/scripts/fetch" "$rvm_ruby_url"

          result=$?

          if [[ "$result" -gt 0 ]] ; then
            "$rvm_path/scripts/log" "error" \
              "There has been an error while trying to fetch the source. Halting the installation."
            return $result
          fi

          mkdir -p ${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string

          unzip -o -j "${rvm_archives_path:-"$rvm_path/archives"}/$rvm_ruby_package_file" \
            "MacRuby ${rvm_ruby_version}/MacRuby ${rvm_ruby_version}.pkg" \
            -d "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"

          mv "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/MacRuby ${rvm_ruby_version}.pkg" \
            "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/$rvm_ruby_string.pkg"

          __rvm_run "macruby/extract" \
            "sudo /usr/sbin/installer -pkg '${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/$rvm_ruby_string.pkg' -target '/'"

          mkdir -p "$rvm_ruby_home/bin"
        fi

        binaries=(erb gem irb rake rdoc ri ruby testrb)
        for binary_name in ${binaries[@]}; do
          # TODO: This should be generated via an external script.
          ruby_wrapper=$(cat <<RubyWrapper
#!/usr/bin/env bash

export GEM_HOME="\${GEM_HOME:-$rvm_ruby_gem_home}"
export GEM_PATH="\${GEM_PATH:-$rvm_ruby_gem_path}"
export MY_RUBY_HOME="$rvm_ruby_home"
export PATH="$rvm_ruby_gem_home/bin:$rvm_ruby_global_gems_path/bin:$rvm_ruby_home/bin:\$PATH"

exec "$macruby_path/mac$binary_name" "\$@"
RubyWrapper
)

          file_name="$rvm_ruby_home/bin/$binary_name"

          if [[ -f "$file_name" ]] ; then
            rm -f "$file_name"
          fi

          echo "$ruby_wrapper" > "$file_name"

          if [[ -f "$file_name" ]] ; then
            chmod +x $file_name
          fi

          if [[ "$binary_name" = "ruby" ]] ; then
            echo "$ruby_wrapper" \
              > "${rvm_bin_path:-"$rvm_bin_path/bin"}/$rvm_ruby_string"
          fi
        done ; unset binaries

        __rvm_irbrc

      else
        "$rvm_path/scripts/log" "fail" \
          "MacRuby can only be installed on a Darwin OS."
      fi
    ;;

    ree)
      if [[ -n "$(echo "$rvm_ruby_version" | awk '/^1\.8/')" \
        && $rvm_head_flag -eq 0 ]] ; then

        rvm_ruby_url="$(__rvm_db "ree_${rvm_ruby_version}_url")/$rvm_ruby_package_file.tar.gz"

        "$rvm_path/scripts/log" "info" \
          "Installing Ruby Enterprise Edition from source to: $rvm_ruby_home"

        builtin cd "${rvm_src_path:-"$rvm_path/src"}"

        if [[ ${rvm_force_flag:-0} -eq 0 \
          && -d "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string" \
          && ! -x "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/installer" ]] ; then

          "$rvm_path/scripts/log" \
            "It appears that the archive has already been extracted. Skipping extract (use --force to force re-download and extract)."

        else
          "$rvm_path/scripts/log" \
            "$rvm_ruby_string - #fetching ($rvm_ruby_package_file)"

          "$rvm_path/scripts/fetch" \
            "$rvm_ruby_url"
          result=$?

          if [[ "$result" -gt 0 ]] ; then
            "$rvm_path/scripts/log" "error" \
              "There has been an error while trying to fetch the source. \
              \nHalting the installation."
            return $result
          fi

          rm -rf "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"

          __rvm_run "extract" \
            "gunzip < \"${rvm_archives_path:-"$rvm_path/archives"}/$rvm_ruby_package_file.$rvm_archive_extension\" | tar xf - -C ${rvm_src_path:-"$rvm_path/src"}" \
            "$rvm_ruby_string - #extracting $rvm_ruby_package_file to ${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"
          result=$?

          if [[ "$result" -gt 0 ]] ; then
            "$rvm_path/scripts/log" "error" \
              "There has been an error while trying to extract the source. Halting the installation."
            return $result
          fi

          mv "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_package_file" \
            "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"
        fi

        builtin cd "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"

        # wait, what? v v v TODO: Investigate line smell.
        mkdir -p "${rvm_ruby_home}/lib/ruby/gems/1.8/gems"

        if [[ -n "$rvm_configure_flags" ]] ; then
          rvm_configure_flags="${rvm_configure_flags//--/-c --}"
        fi

        if [[ "Darwin" = "$(uname)" && "1.8.6" = "$rvm_ruby_version" \
          && -z "$rvm_ree_options" ]] ; then
          rvm_ree_options="${rvm_ree_options} --no-tcmalloc"
        fi

        __rvm_db "${rvm_ruby_interpreter}_configure_flags" "db_configure_flags"

        __rvm_apply_patches "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/source"
        result=$?

        if [[ "$result" -gt 0 ]] ; then
          "$rvm_path/scripts/log" "error" \
            "There has been an error while trying to apply patches to ree. \
            \nHalting the installation."
          return $result
        fi

        __rvm_run "install" \
          "./installer -a $rvm_path/rubies/$rvm_ruby_string $rvm_ree_options $db_configure_flags $rvm_configure_flags" "$rvm_ruby_string - #installing "

        result=$?

        if [[ "$result" -gt 0 ]] ; then
          "$rvm_path/scripts/log" "error" \
            "There has been an error while trying to run the ree installer. Halting the installation."
          return $result
        fi

        chmod +x "$rvm_ruby_home"/bin/*

        __rvm_rubygems_setup
        __rvm_irbrc
        __rvm_bin_script
        __rvm_post_install
      else

        __rvm_db "${rvm_ruby_interpreter}_${rvm_ruby_version}_repo_url" "rvm_ruby_url"

        if [[ -z "$rvm_ruby_url" ]] ; then
          "$rvm_path/scripts/log" "fail" \
            "rvm does not know the rvm repo url for '${rvm_ruby_interpreter}_${rvm_ruby_version}'"
          result=1

        else
          rvm_ruby_repo_url="$rvm_ruby_url"
          if [[ ${rvm_make_flags_flag:-0} -eq 1 ]] ; then __rvm_make_flags ; fi
          __rvm_install_source $*
        fi
      fi
    ;;

    rbx|rubinius)

      "$rvm_path/scripts/log" "info" "$rvm_ruby_string installing #dependencies "

      # Ensure we have a 1.8.7 compatible ruby installed.
      __rvm_ensure_has_18_compat_ruby || return 1

      # TODO: use 'rvm gems load' here:
      unset CFLAGS LDFLAGS ARCHFLAGS # Important.

      unset GEM_HOME GEM_PATH MY_RUBY_HOME IRBRC

      __rvm_remove_rvm_from_path

      __rvm_conditionally_add_bin_path ; export PATH

      builtin hash -r

      if [[ -n "$(printf "${rvm_ruby_version:-""}" | awk '/^1\./')" \
        && ${rvm_head_flag:-0} -eq 0 ]] ; then

        "$rvm_path/scripts/log" "info" \
          "$rvm_ruby_string #downloading ($rvm_ruby_package_file), this may take a while depending on your connection..."

        "$rvm_path/scripts/fetch" "$rvm_ruby_url"
        result=$?

        if [[ "$result" -gt 0 ]] ; then
          "$rvm_path/scripts/log" "error" \
            "There has been an error while trying to fetch the source. Halting the installation."
          return $result
        fi
        __rvm_run "extract" \
          "gunzip < \"${rvm_archives_path:-"$rvm_path/archives"}/$(basename $rvm_ruby_package_file)\" | tar xf - -C ${rvm_src_path:-"$rvm_path/src"}" \
          "$rvm_ruby_string - #extracting"
        result=$?

        if [[ "$result" -gt 0 ]] ; then
          "$rvm_path/scripts/log" "error" \
            "There has been an error while trying to extract the source. \
            \nHalting the installation."
          return $result
        fi

        # Remove the left over folder first.
        rm -rf "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"

        mv "${rvm_src_path:-"$rvm_path/src"}/rubinius-${rvm_ruby_version}" \
          "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"
      else
        __rvm_db "rubinius_repo_url" "rvm_ruby_repo_url"
        #rvm_ruby_home="$rvm_path/rubies/$rvm_ruby_interpreter-$rvm_ruby_version"
        __rvm_fetch_from_github "rbx"
        result=$?

        if [[ "$result" -gt 0 ]] ; then
          "$rvm_path/scripts/log" "error" \
            "There has been an error while fetching the rbx git repo. \
            \nHalting the installation."
          return $result
        fi
      fi

      builtin cd "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"

      chmod +x ./configure

      __rvm_apply_patches
      result=$?

      if [[ "$result" -gt 0 ]] ; then
        "$rvm_path/scripts/log" "error" \
          "There has been an error while trying to apply patches to rubinius. \
          \nHalting the installation."
        return $result
      fi

      __rvm_db "${rvm_ruby_interpreter}_configure_flags" "db_configure_flags"

      export ruby="$(__rvm_18_compat_ruby)"

      rvm_configure_flags="${rvm_configure_flags:-"--skip-system"}"

      rvm_ruby_configure="$rvm_path/wrappers/$ruby/ruby ${rvm_configure_env:-""} ./configure --prefix=$rvm_ruby_home $db_configure_flags $rvm_configure_flags"
      message="$rvm_ruby_string - #configuring"

      if [[ "$rvm_llvm_flag" = "0" ]] ; then
        rvm_ruby_configure="$rvm_ruby_configure --disable-llvm"

      else
        if [[ "$rvm_ruby_patch_level" = "rc1" ]] ; then
          rvm_ruby_configure="$rvm_ruby_configure --enable-llvm"
        fi
      fi

      __rvm_run "configure" "$rvm_ruby_configure" "$message"
      result=$?

      if [[ "$result" -gt 0 ]] ; then
        "$rvm_path/scripts/log" "error" \
          "There has been an error while running '$rvm_ruby_configure'. \
          \nHalting the installation."
        return $result
      fi

      if [[ "$rvm_trace_flag" -eq 1 ]] ; then
        rvm_ruby_make="$rvm_path/wrappers/$ruby/rake install --trace"
        message="$rvm_ruby_string - #compiling (with --trace)"
      else
        rvm_ruby_make="$rvm_path/wrappers/$ruby/rake install"
        message="$rvm_ruby_string - #compiling"
      fi

      __rvm_run "rake" "$rvm_ruby_make" "$message"
      result=$?

      if [[ "$result" -gt 0 ]] ; then
        "$rvm_path/scripts/log" "error" \
          "There has been an error while running '$rvm_ruby_configure'.\nHalting the installation."
        return $result
      fi ; unset ruby

      # Symlink rubinius wrappers
      ln -fs "$rvm_ruby_home/bin/rbx" "$rvm_ruby_home/bin/ruby"

      # Install IRB Wrapper on Rubinius.
      file_name="$rvm_ruby_home/bin/irb"

      rm -f "$file_name"

      printf '#!/usr/bin/env bash\n' > "$file_name"

      printf "exec '$rvm_ruby_home/bin/rbx' 'irb' \"\$@\"\n" >> "$file_name"

      [[ -f "$file_name" ]] && chmod +x "$file_name"

      # Install Gem Wrapper on Rubinius.
      file_name="$rvm_ruby_home/bin/gem"

      cp -f "$rvm_ruby_home/lib/bin/gem.rb" "$file_name"

      __rvm_inject_ruby_shebang "$file_name"

      if [[ -f "$file_name" ]] ; then
        chmod +x "$file_name"
      fi

      unset file_name

      binaries=(erb ri rdoc)

      __rvm_post_install

      __rvm_irbrc

      __rvm_bin_script
    ;;

    jruby)

      if ! command -v java > /dev/null; then
        printf "java must be installed and in PATH in order to install JRuby."
        return 1
      fi

      builtin cd "${rvm_src_path:-"$rvm_path/src"}"

      __rvm_fetch_ruby
      result=$?

      if [[ "$result" -gt 0 ]] ; then
        "$rvm_path/scripts/log" "error" \
          "There has been an error while trying to fetch the source. \
          \nHalting the installation."
        return $result
      fi

      builtin cd "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"

      if [[ ${rvm_head_flag:-0} -eq 1 ]] ; then

        __rvm_apply_patches

        __rvm_run "ant.dist" "ant dist" "$rvm_ruby_string - #ant dist"

      fi

      mkdir -p "$rvm_ruby_home/bin/"

      case "$rvm_ruby_version" in
        1.3|1.2)
          __rvm_run "nailgun" \
            "builtin cd \"${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/tool/nailgun\" &&  make $rvm_make_flags" \
            "Building Nailgun"
          ;;
        *)
          __rvm_run "nailgun" \
            "builtin cd \"${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/tool/nailgun\" && ${rvm_configure_env:-""} ./configure --prefix=$rvm_ruby_home && make $rvm_make_flags" \
            "Building Nailgun"
          ;;
      esac

      if [[ -z "${rvm_ruby_home:-""}" || "$rvm_ruby_home" = "/" ]] ; then
        echo "WTH?!?! rvm_ruby_home == / ??? not removing." ; return 1000000
      fi

      rm -rf "$rvm_ruby_home"

      __rvm_run "install" \
        "/bin/cp -Rf ${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string $rvm_ruby_home" "$rvm_ruby_string - #installing to $rvm_ruby_home"

      (
        builtin cd "$rvm_ruby_home/bin/"
        for binary in jirb jruby jgem ; do
          ln -nfs "$binary" "${binary#j}"
        done ; unset binary
      )

      # -server is "a lot slower for short-lived scripts like rake tasks, and takes longer to load"
      #sed -e 's#^JAVA_VM=-client#JAVA_VM=-server#' $rvm_ruby_home/bin/jruby > $rvm_ruby_home/bin/jruby.new &&
      #  mv $rvm_ruby_home/bin/jruby.new $rvm_ruby_home/bin/jruby
      chmod +x "$rvm_ruby_home/bin/jruby"

      binaries=(jrubyc jirb_swing jirb jgem rdoc ri spec autospec testrb ast generate_yaml_index.rb)

      for binary in "${binaries[@]}" ; do
        __rvm_inject_gem_env "$rvm_ruby_home/bin/$binary"
      done

      __rvm_inject_ruby_shebang "$rvm_ruby_home/bin/rake"

      __rvm_rubygems_setup

      __rvm_irbrc

      __rvm_bin_script

      __rvm_use

      __rvm_post_install

      # jruby ships with some built in gems, copy them in to place.
      if [[ -d "$rvm_ruby_home/lib/ruby/gems/1.8" ]]; then

        "$rvm_path/scripts/log" "info" "Copying across included gems"

        cp -R "$rvm_ruby_home/lib/ruby/gems/1.8/" "$rvm_ruby_gem_home/"
      fi

      "$rvm_ruby_home/bin/gem" install jruby-launcher
    ;;

    maglev)
      __rvm_ensure_has_18_compat_ruby

      "$rvm_path/scripts/log" "info" \
        "Running MagLev prereqs checking script."

      "$rvm_path/scripts/maglev"
      result=$?

      if [[ "$result" -gt 0 ]] ; then
        "$rvm_path/scripts/log" "error" \
          "Prerequisite checks have failed. Halting the installation."
        return $result
      fi

      builtin cd "${rvm_src_path:-"$rvm_path/src"}"

      if [[ ! -d "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string" \
        || ${rvm_force_flag:-0} -eq 1 ]] ; then

        rm -rf "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/" \
          "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/"

        __rvm_fetch_ruby
        result=$?

        if [[ "$result" -gt 0 ]] ; then
          "$rvm_path/scripts/log" "error" \
            "There has been an error while trying to fetch the source. \
            \nHalting the installation."
          return $result
        fi
      fi

      if [[ ${rvm_head_flag:-0} -eq 1 ]] ; then

        builtin cd "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"

        rvm_gemstone_package_file="GemStone-$(\grep ^GEMSTONE version.txt | cut -f2 -d-).$(uname -sm | \tr ' ' '-')"

        rvm_gemstone_url="${rvm_gemstone_url:-"$maglev_url/${rvm_gemstone_package_file}.${rvm_archive_extension}"}"
      fi

      "$rvm_path/scripts/log" "info" \
        "Downloading the GemStone package, this may take a while depending on your connection..."

      "$rvm_path/scripts/fetch" "$rvm_gemstone_url"
      result=$?

      if [[ "$result" -gt 0 ]] ; then
        "$rvm_path/scripts/log" "error" \
          "There has been an error while trying to fetch the GemStone package. \
          \nHalting the installation."
        return $result
      fi

      builtin cd "${rvm_src_path:-"$rvm_path/src"}"

      if [[ -s "$rvm_ruby_package_file" ]] ; then
        mv "$rvm_ruby_package_file" "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"
      fi

      builtin cd "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"

      __rvm_run "gemstone.extract" \
        "gunzip < \"${rvm_archives_path:-"$rvm_path/archives"}/${rvm_gemstone_package_file}.${rvm_archive_extension}\" | tar xf - -C ${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"
      result=$?

      if [[ "$result" -gt 0 ]] ; then
        "$rvm_path/scripts/log" "error" \
        "There has been an error while trying to extract the GemStone package. \
        \nHalting the installation."
        return $result
      fi

      chmod -R 777 "$rvm_gemstone_package_file" # for now. # WTF?! Crack.smoke!(:huff)

      ln -nfs "$rvm_gemstone_package_file" "gemstone"

      if [[ -z "${rvm_ruby_home:-""}" || "$rvm_ruby_home" = "/" ]] ; then
        echo "WTH?!?! rvm_ruby_home == / ??? not removing." ; return 1000000
      else
        rm -rf $rvm_ruby_home
      fi

      __rvm_run "install" \
        "/bin/cp -Rf ${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string $rvm_ruby_home" \
        "Installing maglev to $rvm_ruby_home"

      (
        builtin cd "$rvm_ruby_home/bin/"

        for binary in maglev-irb maglev-ruby maglev-gem ; do

          ln -nfs "$binary" "${binary#maglev-}"

        done ; unset binary
      )

      binaries=(maglev-ruby maglev-irb maglev-gem)

      for binary in "${binaries[@]}" ; do

        __rvm_inject_gem_env "$rvm_ruby_home/bin/$binary"

      done

      builtin cd "$rvm_ruby_home"

      if [[ $rvm_head_flag -eq 1 ]] ; then

        git submodule update --init

        "$rvm_ruby_home/bin/maglev" force-reload

        ln -sf maglev.demo.key-$(uname -sm | \tr ' ' '-') etc/maglev.demo.key
      fi

      #ln -fs "$rvm_ruby_home/$(echo $rvm_gemstone_package_file | awk -F'.' '{print $1}')" "$rvm_ruby_home/gemstone"

      compatible_ruby="$(__rvm_18_compat_ruby)"

      if [[ ! -e ${rvm_ruby_home}/etc/conf.d/maglev.conf ]] ; then
        "$rvm_path/scripts/log" "info" "Creating default 'maglev' repository."
        "$rvm_path/wrappers/$compatible_ruby/rake" "stone:create[maglev]" >/dev/null 2>&1
      fi

      "$rvm_path/scripts/log" "info" "Generating maglev HTML documentation"
      "$rvm_path/wrappers/$compatible_ruby/rake" rdoc >/dev/null 2>&1

      "$rvm_path/scripts/log" "info" "Generating smalltalk FFI."
      "$rvm_path/wrappers/$compatible_ruby/rake" stwrappers >/dev/null 2>&1

      unset compatible_ruby

      # TODO: Figure out if anything needs to be done with rubygems.
      #__rvm_rubygems_setup
      __rvm_irbrc

      __rvm_bin_script

      __rvm_use
    ;;

    ironruby|ir)
      if ! command -v mono > /dev/null ; then
        printf "mono must be installed and in your path in order to install IronRuby." ; return 1
      fi

      if [[ $rvm_head_flag -eq 1 ]] ; then

        mono_version="$(mono -V | head -n 1 | cut -d ' ' -f5)"

        if "$rvm_path/scripts/match" "$mono_version" "([0-9]+)\.([0-9]+)\.?([0-9]+)?" ; then

          mono_major_ver="$(echo "$mono_version" | cut -d '.' -f1)"

          mono_minor_ver="$(echo "$mono_version" | cut -d '.' -f2)"

          if [[ $mono_major_ver -lt 2 ]] \
            || ( [[ $mono_major_ver -eq 2 && $mono_minor_ver -lt 6 ]] ) ; then
            printf "Mono 2.6 (or greater) must be installed and in your path in order to build IronRuby from the repository."
            printf "Version detected: ${mono_version}"
            return 1
          fi
        else
          printf "Cannot recognize mono version."
          return 1
        fi

        __rvm_ensure_has_18_compat_ruby

        __rvm_fetch_ruby

        if [[ $? -gt 0 ]] ; then result=$? ; return $result ; fi

        builtin cd "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"

        compatible_ruby="$(__rvm_18_compat_ruby)"

        "$rvm_path/wrappers/$compatible_ruby/gem" install pathname2 --no-rdoc --no-ri

        # MONO_LIB=/Library/Frameworks/Mono.framework/Versions/current/lib/
        rvm_ruby_make="$rvm_path/wrappers/$compatible_ruby/rake MERLIN_ROOT=\"${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/Merlin/Main\" compile mono=1 configuration=release --trace"
        __rvm_run "rake" "$rvm_ruby_make" "Building IronRuby..."
        unset compatible_ruby
        if [[ $? -gt 0 ]] ; then result=$? ; return $result ; fi

        rm -rf "$rvm_ruby_home"/*
        mkdir -p "$rvm_ruby_home/bin" "$rvm_ruby_home/lib" \
          "$rvm_ruby_home/lib/ruby" "$rvm_ruby_home/lib/IronRuby"

        cp -r "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/Merlin/Main/Bin/mono_release"/* "$rvm_ruby_home/bin/"
        cp -r "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/Merlin/Main/Languages/Ruby/Scripts/bin"/* "$rvm_ruby_home/bin/"
        cp -r "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/Merlin/External.LCA_RESTRICTED/Languages/Ruby/redist-libs/ruby"/* "$rvm_ruby_home/lib/ruby"
        cp -r "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/Merlin/Main/Languages/Ruby/Libs"/* "$rvm_ruby_home/lib/IronRuby"
      else
        "$rvm_path/scripts/log" "info" \
          "Retrieving IronRuby"

        "$rvm_path/scripts/fetch" "$rvm_ruby_url" \
          "$rvm_ruby_package_file"
        result=$?

        if [[ "$result" -gt 0 ]] ; then
          "$rvm_path/scripts/log" "error" \
            "There has been an error while trying to fetch the source. Halting the installation."
          return $result
        fi

        mkdir -p "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string" "$rvm_ruby_home"

        unzip -o  -d "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string" \
          "${rvm_archives_path:-"$rvm_path/archives"}/${rvm_ruby_package_file}" >> \
          "${rvm_log_path:-"$rvm_path/log"}/$rvm_ruby_string/extract.log" 2>&1
        result=$?

        if [[ "$result" -gt 1 ]] ; then

          "$rvm_path/scripts/log" "error" \
            "There has been an error while trying to extract $rvm_ruby_package_file.\n${rvm_log_path:-"$rvm_path/log"}/$rvm_ruby_string/extract.log might have more details.\nHalting the installation."
          return $result

        fi

        for dir in bin lib silverlight ; do
          cp -Rf "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/$dir" "$rvm_ruby_home/$dir"
        done
      fi

      binaries=(gem irb rdoc rake ri ruby)

      for binary_name in "${binaries[@]}" ; do

        if [[ -s "$rvm_ruby_home/bin/$binary_name" ]] ; then

          tr -d '\r' < "$rvm_ruby_home/bin/$binary_name" > "$rvm_ruby_home/bin/$binary_name.new"

          #sed -e '1,1s=.*=#!'"/usr/bin/env ir=" "$rvm_ruby_home/bin/$binary_name" > "$rvm_ruby_home/bin/$binary_name.new"
          mv -f "$rvm_ruby_home/bin/$binary_name.new" "$rvm_ruby_home/bin/$binary_name"

          chmod +x "$rvm_ruby_home/bin/$binary_name"

        fi
      done ; unset binaries

      sed -e '1,1s=.*=#!'"/usr/bin/env bash=" "$rvm_ruby_home/bin/ir" \
        | \tr -d '\r' > "$rvm_ruby_home/bin/ir.new"

      mv -f "$rvm_ruby_home/bin/ir.new" "$rvm_ruby_home/bin/ir"

      chmod +x "$rvm_ruby_home/bin/ir"

      ln -fs "$rvm_ruby_home/bin/ir" "$rvm_ruby_home/bin/ruby"

      builtin hash -r

      __rvm_run "gems.install" \
        "PATH=\"$rvm_ruby_gem_home/bin:$rvm_ruby_global_gems_path/bin:$rvm_ruby_home/bin:$PATH\" GEM_HOME=\"$rvm_ruby_gem_home\" GEM_PATH=\"$rvm_ruby_gem_home:$rvm_ruby_global_gems_path\" $rvm_ruby_home/bin/gem install --no-rdoc --no-ri rake $rvm_gem_options" \
        "Installing $rvm_gem_name to $dir"
    ;;

    goruby)

      if [[ ${rvm_make_flags_flag:-0} -eq 1 ]] ; then __rvm_make_flags ; fi

      unset GEM_HOME GEM_PATH MY_RUBY_HOME IRBRC

      __rvm_remove_rvm_from_path

      __rvm_conditionally_add_bin_path ; export PATH

      builtin hash -r

      rvm_ruby_home="$rvm_path/rubies/$rvm_ruby_interpreter"

      __rvm_fetch_from_github "ruby" "trunk"

      __rvm_apply_patches ; result=$?

      if [[ "$result" -gt 0 ]] ; then
        "$rvm_path/scripts/log" "error" \
          "There has been an error while trying to apply patches to goruby. \
          \nHalting the installation."
        return $result
      fi

      if [[ ! -s "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/configure" ]] ; then

        if command -v autoconf &> /dev/null ; then

          __rvm_run "autoconf" "autoconf" "Running autoconf"

        else
          "$rvm_path/scripts/log" "fail" \
            "rvm expects autoconf to install this ruby interpreter, autoconf was not found in PATH. \
            \nHalting installation."
          return $result
        fi
      fi

      if [[ -s ./Makefile && -z "$rvm_reconfigure_flag" ]] ; then

        if [[ ${rvm_debug_flag:-0} -gt 0 ]] ; then
          "$rvm_path/scripts/log" "debug" \
            "Skipping configure step, Makefile exists so configure must have already been run."
        fi

      elif [[ -n "$rvm_ruby_configure" ]] ; then

        __rvm_run "configure" "$rvm_ruby_configure"
        result=$?

        if [[ "$result" -gt 0 ]] ; then
          "$rvm_path/scripts/log" "error" \
            "There has been an error while trying to configure the source. \
            \nHalting the installation."
          return $result
        fi

      elif [[ -s ./configure ]] ; then
        local configure_command="${rvm_configure_env:-""} ./configure --prefix=$rvm_ruby_home $rvm_configure_flags"

        __rvm_run "configure" "$configure_command" \
          "Configuring $rvm_ruby_string using $rvm_configure_flags, this may take a while depending on your cpu(s)..."
        result=$?

      if [[ "$result" -gt 0 ]] ; then
        "$rvm_path/scripts/log" "error" \
          "There has been an error while trying to configure the source.\
          \nHalting the installation."
        return $result
	  fi

    else
      "$rvm_path/scripts/log" "error" \
        "Skipping configure step, 'configure' script does not exist, did autoconf not run successfully?"
    fi

      rvm_ruby_make=${rvm_ruby_make:-"make"}

      __rvm_run "make" "$rvm_ruby_make golf $rvm_make_flags" \
        "Compiling $rvm_ruby_string, this may take a while depending on your cpu(s)..."
      result=$?

      if [[ "$result" -gt 0 ]] ; then
        "$rvm_path/scripts/log" "error" \
          "There has been an error while trying to run make.\
          \nHalting the installation."
        return $result
      fi

      rvm_ruby_make_install=${rvm_ruby_make_install:-"make install"}

      __rvm_run "install" "$rvm_ruby_make_install" "Installing $rvm_ruby_string"
      result=$?

      if [[ "$result" -gt 0 ]] ; then
        "$rvm_path/scripts/log" "error" \
          "There has been an error while trying to run make install. \
          \nHalting the installation."
        return $result
      fi

      "$rvm_path/scripts/log" "info" \
        "Installation of $rvm_ruby_string is complete."

      export GEM_HOME="$rvm_ruby_gem_home"
      export GEM_PATH="$rvm_ruby_gem_path"

      __rvm_rubygems_setup

      __rvm_bin_script

      __rvm_run "chmod.bin" "chmod +x $rvm_ruby_home/bin/*"

      __rvm_post_install
	  rm $rvm_ruby_home/bin/ruby
	  ln -s $rvm_ruby_home/bin/goruby $rvm_ruby_home/bin/ruby
    ;;

    ruby)

      __rvm_check_for_bison # && Run like hell...
      if [[ $? -gt 0 ]] ; then return $result ; fi

      if [[ ${rvm_make_flags_flag:-0} -eq 1 ]] ; then __rvm_make_flags ; fi

      ( __rvm_install_source $* )
      result=$?
    ;;

    default)
      "$rvm_path/scripts/log" "fail" \
        "a ruby interpreter to install must be specified and not simply 'default'."
    ;;

    *)
      "$rvm_path/scripts/log" "fail" \
        "Either the ruby interpreter is unknown or there was an error!."
    ;;

  esac

  rvm_hook="after_install" ; source "$rvm_path/scripts/hook"

  if [[ -n "$ruby_options" ]] ; then
    RUBYOPT="$ruby_options"
    export RUBYOPT
  fi

  return ${result:-0}
}

__rvm_fetch_from_github()
{
  rm -rf "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"

  if [[ ! -d "${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string/.git" ]] ; then

    rm -rf "${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string"

    builtin cd "$rvm_home"

    __rvm_run "$1.repo" \
      "git clone --depth 1 $rvm_ruby_repo_url ${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string" \
      "Cloning $rvm_ruby_repo_url"
    result=$?

    if [[ "$result" -gt 0 ]] ; then
      rvm_ruby_repo_http_url="${rvm_ruby_repo_url//git:/http:}"

      "$rvm_path/scripts/log" "info" "Could not fetch $rvm_ruby_repo_url - trying $rvm_ruby_repo_http_url"

      __rvm_run "$1.repo" "git clone --depth 1 $rvm_ruby_repo_http_url ${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string" "Cloning $rvm_ruby_repo_http_url"
    fi
  else
    local branch="${rvm_ruby_repo_branch:-"master"}"

    builtin cd "${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string"

    __rvm_run "$1.repo" "git pull origin $branch" "Pulling from origin $branch"
  fi

  (
    remote="origin"

    cd "${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string"

    if [[ -z "$(git branch | awk "/$rvm_ruby_repo_branch$/")" ]] ; then

      git checkout -b "$rvm_ruby_repo_branch" --track "$remote/$rvm_ruby_repo_branch" 2>/dev/null

    elif [[ -z "$(git branch | awk "/\* $rvm_ruby_repo_branch$/")" ]] ; then

      if ! git checkout $rvm_ruby_repo_branch 2>/dev/null ; then

        "$rvm_path/scripts/log" "error" \
          "Branch $remote/$rvm_ruby_repo_branch not found."

      fi

    fi
  )

  rm -rf "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"

  __rvm_run "$1.copy" "\\cp -R \"${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string\" \"${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string\"" "Copying from repo to source..."

  builtin cd "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"

  return ${result:-0}
}

__rvm_fetch_ruby()
{
  [[ ${rvm_ruby_selected_flag:-0} -eq 0 ]] && __rvm_select

  "$rvm_path/scripts/log" "info" "$rvm_ruby_string - #fetching "

  if [[ ${rvm_head_flag:-0} -eq 0 && -z "${rvm_ruby_tag:-""}" && -z "${rvm_ruby_revision:-""}" ]] ; then

    rvm_ruby_package_name="${rvm_ruby_package_name:-"$rvm_ruby_string"}"

    rvm_ruby_package_file="${rvm_ruby_package_file:-"$rvm_ruby_package_name"}"

    if [[ "ruby" = "$rvm_ruby_interpreter" ]]; then
      rvm_archive_extension="${rvm_archive_extension:-tar.bz2}"
    else
      rvm_archive_extension="${rvm_archive_extension:-tar.gz}"
    fi

    if [[ ! -s "${rvm_archives_path:-"$rvm_path/archives"}/$rvm_ruby_package_file.$rvm_archive_extension" ]] ; then

      case "$rvm_ruby_interpreter" in
        ruby)
          rvm_ruby_url="$(__rvm_db "${rvm_ruby_interpreter}_${rvm_ruby_release_version}.${rvm_ruby_major_version}_url")/$rvm_ruby_package_file.$rvm_archive_extension"
          ;;
        ree)
          rvm_ruby_url="$(__rvm_db "${rvm_ruby_interpreter}_${rvm_ruby_version}_url")/${rvm_ruby_package_file}.${rvm_archive_extension}"
          ;;
        jruby)
          rvm_ruby_url="$(__rvm_db "${rvm_ruby_interpreter}_url")/${rvm_ruby_version}/${rvm_ruby_package_file}.${rvm_archive_extension}"
          ;;
        maglev)
          : # Should already be set from selector
          ;;
        *)
          rvm_ruby_url="$(__rvm_db "${rvm_ruby_interpreter}_url")/${rvm_ruby_package_file}.${rvm_archive_extension}"
          ;;
      esac

      "$rvm_path/scripts/log" "info" \
        "$rvm_ruby_string - #downloading ${rvm_ruby_package_file}, this may take a while depending on your connection..."

      "$rvm_path/scripts/fetch" "${rvm_ruby_url}"
      result=$?

      if [[ "$result" -gt 0 ]] ; then
        "$rvm_path/scripts/log" "error" \
          "There has been an error while trying to fetch the source. \
          \nHalting the installation."
        return $result
      fi
    fi

    if [[ ! -d "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string" \
      || ${rvm_force_flag:-0} -eq 1 ]] ; then

      if [[ -d "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string" ]] ; then
        # Especially when forced, we want to ensure the destination is missing.
        rm -rf "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"
      fi

      mkdir -p "${rvm_tmp_path:-/tmp}/rvm_src_$$"

      case "$rvm_archive_extension" in
        tar.gz|tgz)
          __rvm_run "extract" "gunzip < \"${rvm_archives_path:-"$rvm_path/archives"}/$rvm_ruby_package_file.$rvm_archive_extension\" | tar xf - -C ${rvm_tmp_path:-/tmp}/rvm_src_$$" "$rvm_ruby_string - #extracting $rvm_ruby_package_file to ${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"
          result=$?

          if [[ "$result" -gt 0 ]] ; then
            "$rvm_path/scripts/log" "error" \
              "There has been an error while trying to extract the source. \
              \nHalting the installation."
            return $result
          fi
          ;;
        zip)
          __rvm_run "extract" "unzip -q -o ${rvm_archives_path:-"$rvm_path/archives"}/$rvm_ruby_package_file -d ${rvm_tmp_path:-/tmp}/rvm_src_$$"
          result=$?

          if [[ "$result" -gt 0 ]] ; then
            "$rvm_path/scripts/log" "error" \
              "There has been an error while trying to extract $rvm_ruby_package_file. \
              \nHalting the installation."
            return $result
          fi
          ;;
        tar.bz2)
          __rvm_run "extract" "bunzip2 < '${rvm_archives_path:-"$rvm_path/archives"}/$rvm_ruby_package_file.$rvm_archive_extension' | tar xf - -C ${rvm_tmp_path:-/tmp}/rvm_src_$$" "$rvm_ruby_string - #extracting $rvm_ruby_package_file to ${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"
          result=$?

          if [[ "$result" -gt 0 ]] ; then
            "$rvm_path/scripts/log" "error" \
              "There has been an error while trying to extract the source. \
              \nHalting the installation."
            return $result
          fi
          ;;
        *)
          "$rvm_path/scripts/log" "error" \
            "Unknown archive format extension '$rvm_archive_extension'. \
            \nHalting the installation."
          return 1
          ;;
      esac

      if [[ -d "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string" ]] ; then
        rm -rf "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"
      fi
      mv "${rvm_tmp_path:-/tmp}/rvm_src_$$/$(builtin cd ${rvm_tmp_path:-/tmp}/rvm_src_$$ ; ls)" "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string" ; rm -rf "${rvm_tmp_path:-/tmp}/rvm_src_$$"

      if [[ -n "${rvm_ruby_name:-""}" && -d "${rvm_src_path:-"$rvm_path/src"}/$(echo $rvm_ruby_string | sed -e 's/-n.*//')" ]] ; then
        mv "${rvm_src_path:-"$rvm_path/src"}/$(echo "$rvm_ruby_string" | sed -e 's/-n.*//')" "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"
      fi

      "$rvm_path/scripts/log" "info" \
        "$rvm_ruby_string - #extracted to ${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"

    else
      "$rvm_path/scripts/log" "info" \
        "$rvm_ruby_string - #extracted to ${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string (already extracted)"
    fi

    return 0

  else # -head

    mkdir -p "${rvm_repo_path:-"$rvm_path/repos"}"

    if [[ -z "${rvm_ruby_url:-""}" ]] ; then
      rvm_ruby_url="$rvm_ruby_repo_url"
    fi

    if echo "$rvm_ruby_url" | grep -q 'git' ; then # Using a  git url.

      # Determine Branch
      if [[ -z "${rvm_ruby_repo_branch:-""}" ]]; then

        if [[ -n "${rvm_ruby_major_version:-""}" ]] ; then

          if [[ -n "${rvm_ruby_minor_version:-""}" ]]; then
            rvm_ruby_repo_branch="ruby_1_${rvm_ruby_major_version}_${rvm_ruby_minor_version}"
          else
            rvm_ruby_repo_branch="ruby_1_${rvm_ruby_major_version}"
          fi

        else

          rvm_ruby_repo_branch="trunk" # NOTE: Ruby Core team maps 'trunk' as HEAD

        fi

      fi

      # Clone if repository does not yet exist locally
      if [[ ! -d "${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string/.git" ]] ; then

        rm -rf "${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string"

        rvm_ruby_repo_http_url="${rvm_ruby_repo_url//git:/https:/}"

        "$rvm_path/scripts/log" "info" \
          "Cloning from $rvm_ruby_repo_url, this may take a while depending on your connection..."

        git clone --depth 1 "$rvm_ruby_repo_url" \
          "${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string"
        result=$?

        if [[ "$result" -gt 0 ]] ; then
          "$rvm_path/scripts/log" "info" \
            "cloning from $rvm_ruby_repo_url failed, now attempting to clone from $rvm_ruby_repo_http_url, this may take a while depending on your connection..."

          git clone "$rvm_ruby_repo_http_url" \
            "${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string"
          result=$?

          if [[ "$result" -gt 0 ]] ; then
            "$rvm_path/scripts/log" "error" \
              "There has been an error while trying to fetch the repository. \
              \nHalting the installation."
            return $result
          fi
        fi

      fi

      # Use the selected branch.
      (
        remote="${remote:-origin}"

        cd "${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string" &&

        if ! git branch  | grep '^*' | grep -q "${rvm_ruby_repo_branch}" ; then

          # Not already on the desired branch
          if ! git branch  | grep -q "^  ${rvm_ruby_repo_branch}" ; then

            git checkout "${rvm_ruby_repo_branch}" # Branch is local
            git pull "$remote" "${rvm_ruby_repo_branch}"

          else # Branch is not local

            if ! git checkout -t "${remote}/${rvm_ruby_repo_branch}" ; then
              result=$?

              "$rvm_path/scripts/log" "error" \
                "Branch $remote/$rvm_ruby_repo_branch not found."
              return $result

            fi
          fi

        else
          true
        fi
      )
      result=$?

      if [[ "$result" -gt 0 ]] ; then
        "$rvm_path/scripts/log" "error" \
          "There has been an error while checking out branch ${rvm_ruby_repo_branch}. \
          \nHalting the installation."
        return $result
      fi

      # If a revision was specified, check it out.
      if [[ -n "$rvm_ruby_revision" ]] ; then

        if [[ -z "${rvm_ruby_sha:-""}" ]] ; then
          git checkout HEAD
        else
          git checkout ${rvm_ruby_sha/#s/}
        fi
        result=$?

        if [[ "$result" -gt 0 ]] ; then
          "$rvm_path/scripts/log" "error" \
            "There has been an error while trying to checkout the source branch.\nHalting the installation."
          return $result
        fi
      fi

    else
      if [[ -n "${rvm_ruby_tag:-""}" ]] ; then
        # TODO: Check if tag v is valid
        rvm_ruby_url="${rvm_ruby_url:-"$rvm_ruby_repo_url/tags/$(echo "$rvm_ruby_tag" | sed 's/^t//')"}"

      elif [[ -z "${rvm_ruby_version:-""}" && ${rvm_head_flag:-0} -eq 1 ]] ; then
        rvm_ruby_url="${rvm_ruby_url:-"$rvm_ruby_repo_url/trunk"}"

      elif [[  "${rvm_ruby_major_version:-""}" = "9" ]] ; then

        if [[ -z "${rvm_ruby_minor_version:-""}" || "${rvm_ruby_minor_version:-""}" = 3 ]] ; then
          rvm_ruby_url="${rvm_ruby_url:-"$rvm_ruby_repo_url/trunk"}"

        else
          rvm_ruby_url="${rvm_ruby_url:-"$rvm_ruby_repo_url/branches/ruby_${rvm_ruby_release_version}_${rvm_ruby_major_version}_${rvm_ruby_minor_version}"}"
        fi

      elif [[ -z "${rvm_ruby_minor_version:-""}" || "${rvm_ruby_major_version:-""}.${rvm_ruby_minor_version:-""}" = "8.8" ]] ; then
        rvm_ruby_url="${rvm_ruby_url:-"$rvm_ruby_repo_url/branches/ruby_${rvm_ruby_release_version}_${rvm_ruby_major_version}"}"

      else
        rvm_ruby_url="${rvm_ruby_url:-"$rvm_ruby_repo_url/branches/ruby_${rvm_ruby_release_version}_${rvm_ruby_major_version}_${rvm_ruby_minor_version}"}"
      fi

      rvm_rev=""

      if [[ -n "${rvm_ruby_revision:-""}" ]] ; then
        rvm_rev="-$rvm_ruby_revision"
      fi

      if [[ -d "${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string/.svn" ]] ; then

        builtin cd "${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string"

        "$rvm_path/scripts/log" "info" "Updating ruby from $rvm_ruby_url"

        __rvm_run "svn.switch" "svn switch $rvm_ruby_url"

        __rvm_run "svn.update" "svn update"

        if [[ -n "${rvm_rev:-""}" ]] ; then
          "$rvm_path/scripts/log" "info" "Checking out revision ${rvm_rev/-r/-r } from $rvm_ruby_url"

          __rvm_run "svn.checkout" "svn update -q ${rvm_rev/-r/-r }"
        fi
      else
        rm -rf "${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string"

        __rvm_run "svn.checkout" \
          "svn checkout -q ${rvm_rev/-r/-r } $rvm_ruby_url ${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string" \
          "Downloading source from ${rvm_ruby_url}."
      fi
      result=$?

      if [[ "$result" -gt 0 ]] ; then
        "$rvm_path/scripts/log" "error" \
          "There has been an error while trying to fetch / update the source. \
          \nHalting the installation."
        return $result
      fi
    fi

    "$rvm_path/scripts/log" "info" "Copying from repo to src path..."

    rm -rf "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"

    cp -R "${rvm_repos_path:-"$rvm_path/repos"}/$rvm_ruby_string" \
      "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string"
  fi

  return ${result:-0}
}

__rvm_check_default()
{
  local default_ruby_interpreter current_ruby_interpreter

  default_ruby_interpreter="$(rvm alias show default 2>/dev/null \
    | awk -F"${rvm_gemset_separator:-"@"}" '{print $1}')"

  current_ruby_interpreter="$(echo "$rvm_ruby_string" \
    | awk -F"${rvm_gemset_separator:-"@"}" '{print $1}')"

  if [[ -n "$current_ruby_interpreter" \
    && "$current_ruby_interpreter" = "$default_ruby_interpreter" ]]; then

    __rvm_run_with_env 'default.restore' 'system' \
      'rvm use system --default' 'Removing default ruby interpreter'

  fi

  return $?
}

__rvm_uninstall_ruby()
{
  local dir

  if [[ ${rvm_ruby_selected_flag} -eq 0 ]] ; then __rvm_select ; fi

  if [[ -n "${rvm_ruby_string:-""}" ]] ; then

    for dir in "$rvm_path/rubies" ; do

      if [[ -d "$dir/$rvm_ruby_string" ]] ; then

        "$rvm_path/scripts/log" "info" "Removing $dir/$rvm_ruby_string..."

        rm -rf $dir/$rvm_ruby_string

      else

        "$rvm_path/scripts/log" "info" \
          "$dir/$rvm_ruby_string has already been removed."

      fi

      if [[ -e "${rvm_bin_path:-"$rvm_path/bin"}/$rvm_ruby_string" ]] ; then

        rm -f "${rvm_bin_path:-"$rvm_path/bin"}/$rvm_ruby_string"

      fi

    done

    __rvm_remove_install_record "$rvm_ruby_string"

    __rvm_remove_gemsets

    __rvm_check_default

  else

    "$rvm_path/scripts/log" "fail" \
      "Cannot uninstall unknown package '$rvm_ruby_string'"

  fi

  unset rvm_uninstall_flag

  return 0
}

__rvm_remove_ruby()
{
  local dir

  if [[ ${rvm_ruby_selected_flag:-0} -eq 0 ]] ; then __rvm_select ; fi

  if [[ -n "${rvm_ruby_string:-""}" ]] ; then

    for dir in ${rvm_src_path:-"$rvm_path/src"} $rvm_path/rubies ; do

      if [[ -d $dir/$rvm_ruby_string ]] ; then

        "$rvm_path/scripts/log" "info" "Removing $dir/$rvm_ruby_string..."

        rm -rf "$dir/$rvm_ruby_string"

      else

        "$rvm_path/scripts/log" "info" \
          "it seems that $dir/$rvm_ruby_string is already non existent."

      fi

      if [[ -e "${rvm_bin_path:-"$rvm_path/bin"}/$rvm_ruby_string" ]] ; then

        rm -f "${rvm_bin_path:-"$rvm_path/bin"}/$rvm_ruby_string"

      fi

      __rvm_check_default

    done

    __rvm_remove_install_record "$rvm_ruby_string"
    __rvm_remove_gemsets
    __rvm_remove_archives
    __rvm_remove_aliases
    __rvm_remove_wrappers
    __rvm_remove_environments
    __rvm_remove_binaries

  else

    "$rvm_path/scripts/log" "fail" \
      "Cannot remove unknown package '$rvm_ruby_string'"

    return 1

  fi

  unset rvm_remove_flag

  return 0
}

__rvm_remove_gemsets()
{
  local gemset gemsets

  if [[ ${rvm_gems_flag:-0} -eq 1 ]] ; then

    "$rvm_path/scripts/log" "info" "Removing $rvm_ruby_string gemsets..."

    gemsets=( $(find "${rvm_gems_path:-"$rvm_path/gems"}" -iname "${rvm_ruby_string}*" -maxdepth 1 -type d))

    for gemset in "${gemsets[@]}" ; do

      if [[ -d "$gemset" ]] ; then

        rm -rf "$gemset"

      fi

    done

  fi
}

__rvm_remove_wrappers()
{
  "$rvm_path/scripts/log" "info" "Removing $rvm_ruby_string wrappers..."

  local wrapper wrappers

  wrappers=($(find "$rvm_path/wrappers" -maxdepth 1 -mindepth 1 -type d -iname "*$rvm_ruby_string*" 2>/dev/null))

  for wrapper in "${wrappers[@]}" ; do

    rm -rf "$wrapper"

  done

  return 0
}

__rvm_remove_environments()
{
  "$rvm_path/scripts/log" "info" "Removing $rvm_ruby_string environments..."

  local environments environment

  environments=($(find "$rvm_path/environments" -maxdepth 1 -mindepth 1 -type f -iname "*$rvm_ruby_string*" ))

  for environment in "${environments[@]}" ; do
    if [[ -d "$environment" ]] ; then
      rm -rf "$environment"
    fi
  done

  return 0
}

__rvm_remove_aliases()
{
  "$rvm_path/scripts/log" "info" "Removing $rvm_ruby_string aliases..."

  local alias_name aliases

  aliases=($(awk '/'$rvm_ruby_string'/' "$rvm_path/config/alias" | sed 's/=.*//'))

  for alias_name in "${aliases[@]}" ; do
    # Remove from alias key-value store
    "$rvm_path/scripts/alias" delete "$alias_name" >/dev/null 2>&1
  done
}

__rvm_remove_archives()
{
  if [[ ${rvm_archive_flag:-0} -eq 1 ]] ; then

    "$rvm_path/scripts/log" "info" "Removing $rvm_ruby_string archives..."

    rm -f "${rvm_archives_path:-"$rvm_path/archives"}/${rvm_ruby_package_file}.${rvm_archive_extension}"
  fi
}

__rvm_remove_binaries()
{
  "$rvm_path/scripts/log" "info" "Removing $rvm_ruby_string binaries..."

  # Iterate over all binaries and check for symlinked wrappers etc.
  local binary_name binaries full_patch_path

  binaries=($(find "${rvm_bin_path:-"$rvm_path/bin"}" -maxdepth 1 -mindepth 1 -type f -iname "*$rvm_ruby_string*" ))

  for binary_name in "${binaries[@]}" ; do

    full_binary_path="${rvm_bin_path:-"$rvm_path/bin"}/$binary_name"

    if [[ -L "$full_binary_path" ]] \
      && "$rvm_path/scripts/match" "$(readlink "$full_binary_path")" "$rvm_ruby_string"; then
      rm -f "$full_binary_path"
    fi
  done ; unset binaries

  return 0
}

__rvm_post_install()
{
  local rvm_ruby_aliases ruby_alias binary

  if [[ "$rvm_ruby_interpreter" != "jruby" ]] ; then

    if [[ ${#binaries[@]} -lt 1 ]] ; then
      binaries=(gem irb erb ri rdoc testrb rake)
    fi

    "$rvm_path/scripts/log" "info" \
      "$rvm_ruby_string - adjusting #shebangs for ($binaries)."

    for binary in "${binaries[@]}" ; do

      if [[ -e "$rvm_ruby_home/bin/$binary" \
        || -e "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/bin/$binary" ]] ; then

        if [[ "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string" != "$rvm_ruby_home" \
          && -f "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/bin/$binary" ]] ; then

          cp -f "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/bin/$binary" "$rvm_ruby_home/bin/$binary"

        elif [[ -f "$rvm_ruby_gem_home/bin/$binary" ]] ; then

          cp -f "$rvm_ruby_gem_home/bin/$binary" "$rvm_ruby_home/bin/$binary"
        fi

        __rvm_inject_gem_env "$rvm_ruby_home/bin/$binary"

        __rvm_inject_ruby_shebang "$rvm_ruby_home/bin/$binary"

        chmod +x "$rvm_ruby_home/bin/$binary"
      fi
    done

    binaries=(gem irb erb ri rdoc testrb rake)
  fi

  # Import the initial gemsets.
  __rvm_run_with_env "gemsets.initial" "$rvm_ruby_string" \
    "'$rvm_path/scripts/gemsets' initial" \
    "$rvm_ruby_string - #importing default gemsets ($rvm_path/gemsets/)"

  __rvm_irbrc

  __rvm_generate_default_docs

  if [[ -n "$rvm_ruby_aliases" ]]; then
    "$rvm_path/scripts/log" "info" "Setting up aliases for $rvm_ruby_string"

    while read -r ruby_alias; do

      "$rvm_path/scripts/log" info "Aliasing $rvm_ruby_string to $ruby_alias"

      "$rvm_path/scripts/alias" delete "$ruby_alias" > /dev/null 2>&1

      "$rvm_path/scripts/alias" create "$ruby_alias" "$rvm_ruby_string" > /dev/null 2>&1

    done < <(echo "$rvm_ruby_string" | \tr ' ' '\n' | sort -u)
  fi
}

__rvm_generate_default_docs()
{
  if [[ "$rvm_docs_flag" = "1" && "$rvm_ruby_interpreter" != "macruby" ]]; then

    __rvm_run_with_env "docs.generate" "$rvm_ruby_string" \
      "rvm docs generate-ri" "Attempting to generate ri documentation..."
  fi
}

__rvm_rubygems_setup()
{
  local home path dir directory_name version_number ruby_lib_gem_path

  if [[ -n "$(echo "$rvm_ruby_version" | awk '/^1\.9/')" \
    || -n "$(echo "$rvm_ruby_interpreter" | awk '/^goruby/')" ]] ; then

    install=0

  elif [[ "$rvm_ruby_string" = "ruby-head" ]] ; then
    install=0

  else
    install=1
  fi

  __rvm_use

  if [[ "$install" -eq 0 ]] ; then
    # 1.9.X has it's own built-in gem command
    __rvm_inject_ruby_shebang "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/bin/gem"

    __rvm_inject_gem_env "$rvm_ruby_home/bin/gem"

    cp "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/bin/gem" "$rvm_ruby_home/bin/gem"

    home="$GEM_HOME" ; path="$GEM_PATH" # Save

    for dir in $rvm_ruby_global_gems_path $rvm_ruby_gem_home ; do

      export GEM_HOME="$dir" ; export GEM_PATH="$dir"

      __rvm_run "rubygems.update" \
        "$rvm_ruby_home/bin/gem update --system" "$rvm_ruby_string - updating #rubygems for $dir"

    done

    GEM_HOME="$home" ; GEM_PATH="$path"
    export GEM_HOME GEM_PATH

    __rvm_inject_ruby_shebang "$rvm_ruby_home/bin/gem"

    __rvm_inject_gem_env "$rvm_ruby_home/bin/gem"

    directory_name="$rvm_ruby_home/lib/ruby/gems"

    version_number="${rvm_ruby_release_version}.${rvm_ruby_major_version}"

    if [[ "$version_number" == "." ]]; then

      # TODO: Investigate this if statement, something feels not quite right.
      version_number="$(builtin cd "$directory_name" ; \
        find . -maxdepth 1 -mindepth 1 -type f \
        | \grep '^[[:digit:]].[[:digit:]]\(.[[:digit:]]\)\?' | head -n1)"
      version_number="${version_number//.\/}"

      if [[ -n "$version_number" ]]; then
        ruby_lib_gem_path="${directory_name}/${version_number}"
      else
        ruby_lib_gem_path=""
      fi

    else
      ruby_lib_gem_path="${directory_name}/${version_number}"
    fi

  elif [[ -n "$(echo "$rvm_ruby_interpreter" | awk '/^rbx|jruby/')" ]] ; then

    # Hands off rubygems for rbx & jruby
    if [[ ${rvm_debug_flag:-0} -gt 0 ]] ; then
      "$rvm_path/scripts/log" "debug" \
        "Skipping rubygems update for $rvm_ruby_version"
    fi

    ruby_lib_gem_path="$rvm_ruby_home/lib/ruby/gems/jruby"

  else

    "$rvm_path/scripts/log" "info" \
      "$rvm_ruby_string - #rubygems installing to $rvm_ruby_string"

    rvm_rubygems_version="$(__rvm_db "${rvm_ruby_interpreter}_rubygems_version")"
    rvm_rubygems_version="${rvm_rubygems_version:-"$(__rvm_db "rubygems_version")"}"
    rvm_rubygems_url=$(__rvm_db "rubygems_${rvm_rubygems_version}_url")
    rvm_gem_package_name="rubygems-$rvm_rubygems_version"
    rvm_gem_url="$rvm_rubygems_url/$rvm_gem_package_name.tgz"

    # Sanity check... If setup.rb is missing from the rubygems source path,
    # something went wrong. Cleanup, aisle 3!
    if [[ ! -f "${rvm_src_path:-"$rvm_path/src"}/$rvm_gem_package_name/setup.rb" ]]; then
      rm -rf "${rvm_src_path:-"$rvm_path/src"}/$rvm_gem_package_name"
    fi

    if [[ ! -d "${rvm_src_path:-"$rvm_path/src"}/$rvm_gem_package_name" ]] ; then

      "$rvm_path/scripts/log" "info" "Retrieving $rvm_gem_package_name"

      "$rvm_path/scripts/fetch" "$rvm_gem_url"
      result=$?

      if [[ "$result" -gt 0 ]] ; then
        "$rvm_path/scripts/log" "error" \
          "There has been an error while trying to fetch the source. Halting the installation." ; return $result
      fi

      if [[ ! -d "${rvm_src_path:-"$rvm_path/src"}/$rvm_gem_package_name" ]] ; then
        mkdir -p "${rvm_src_path:-"$rvm_path/src"}/$rvm_gem_package_name"
      fi

      __rvm_run "rubygems.extract" \
        "gunzip < \"${rvm_archives_path:-"$rvm_path/archives"}/$rvm_gem_package_name.tgz\" | tar xf - -C ${rvm_src_path:-"$rvm_path/src"}" \
        "Extracting $rvm_gem_package_name ..."
    fi

    builtin cd "${rvm_src_path:-"$rvm_path/src"}/$rvm_gem_package_name"

    __rvm_run "rubygems.install" \
      "GEM_PATH='$rvm_ruby_gem_path:$rvm_ruby_global_gems_path' GEM_HOME='$rvm_ruby_gem_home' $rvm_ruby_home/bin/ruby ${rvm_src_path:-"$rvm_path/src"}/$rvm_gem_package_name/setup.rb"
    result=$?

    if [[ $result -gt 0 ]] ; then
      "$rvm_path/scripts/log" "warning" \
        "$rvm_ruby_string - #warning Installation of rubygems $rvm_ruby_package_name did not complete successfully."
    fi

    __rvm_inject_ruby_shebang "$rvm_ruby_home/bin/gem"

    if [[ -n "$rvm_ruby_major_version" ]] ; then
      ruby_lib_gem_path="$rvm_ruby_home/lib/ruby/gems/${rvm_ruby_release_version}.$rvm_ruby_major_version"
    else
      ruby_lib_gem_path="$rvm_ruby_home/lib/ruby/gems/$interpreter"
    fi
  fi

  if [[ -n "$ruby_lib_gem_path" ]]; then
    # Add ruby's gem path to ruby's lib direcotry.

    if [[ -d "$ruby_lib_gem_path" ]] ; then
      rm -rf "$ruby_lib_gem_path"
    fi

    mkdir -p ${ruby_lib_gem_path%\/*}

    ln -nfs "$rvm_ruby_gem_home" "$ruby_lib_gem_path"

  fi

  if [[ -s "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/bin/rdoc" ]] ; then
    __rvm_inject_ruby_shebang "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/bin/rdoc"
  fi

  if [[ -s "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/bin/rake" ]] ; then
    __rvm_inject_ruby_shebang "${rvm_src_path:-"$rvm_path/src"}/$rvm_ruby_string/bin/rake"
  fi

  return ${result:-0}
}

__rvm_inject_ruby_shebang()
{
  local actual_file

  __rvm_actual_file $1

  if [[ -f "$actual_file" ]] ; then
    sed -e '1,1s=.*=#!'"/usr/bin/env ruby=" ${actual_file} > "${actual_file}.new"

    mv "${actual_file}.new" "${actual_file}" ; chmod +x "$actual_file"
  fi
}

__rvm_inject_gem_env()
{
  local actual_file string

  __rvm_actual_file $1

  if [[ -s "$actual_file" ]] ; then

    if [[ -n "$(head -n 1 "$actual_file" | awk '/[j]*ruby/')" ]] ; then

      string="ENV['GEM_HOME']=ENV['GEM_HOME'] || '$rvm_ruby_gem_home'\nENV['GEM_PATH']=ENV['GEM_PATH'] || '$rvm_ruby_gem_path'\nENV['PATH']='$rvm_ruby_gem_home/bin:$rvm_ruby_global_gems_path/bin:$rvm_ruby_home/bin:' + ENV['PATH']\n"

    elif [[ -n "$(head -n 1 "$actual_file" | awk '/bash/')" ]] ; then

      string="GEM_HOME=\${GEM_HOME:-'$rvm_ruby_gem_home'}\nGEM_PATH=\${GEM_PATH:-'$rvm_ruby_gem_home:$rvm_ruby_global_gems_path'}\nPATH=$rvm_ruby_gem_home/bin:$rvm_ruby_global_gems_path/bin:$rvm_ruby_home/bin:\$PATH\n"

    fi

    if [[ -n "$string" ]] ; then

      awk "NR==2 {print \"$string\"} {print}" "$actual_file" \
        > "$actual_file.new"

      mv $actual_file.new $actual_file ; chmod +x "$actual_file"

    fi
  fi

  return 0
}

__rvm_actual_file()
{
  if [[ -L "$1" ]] ; then # If the file is a symlink,

    actual_file="$(readlink $1)" # read the link target so we can preserve it.

  else

    actual_file="$1"

  fi

  return 0
}

__rvm_manage_rubies()
{
  local manage_result bin_line

  manage_result=0

  rvm_gemset_name=""
  rvm_ruby_selected_flag=0

  rvm_ruby_gem_home="${rvm_ruby_gem_home:-""//${rvm_gemset_separator:-"@"}*}"
  rvm_ruby_string="${rvm_ruby_string:-""//${rvm_gemset_separator:-"@"}*}"

  # TODO: See if this can work, currently errors out on 'cannot find i386' libs.
  # __rvm_setup_compile_environment

  # Given list of ruby strings.
  if [[ -n "${rubies_string:-""}" ]] ;then

    rubies=(${rubies_string//,/ })

    for rvm_ruby_string in "${rubies[@]}" ; do

      current_ruby_string="$rvm_ruby_string"

      rvm_hook="before_install" ; source "$rvm_path/scripts/hook"

      eval "__rvm_${action}_ruby"
      result="$?"

      if [[ "$result" -gt 0 && "$manage_result" = 0 ]]; then
        manage_result="$result"
      fi

      if [[ "$result" = 0 && "$action" = "install" ]] ; then
        __rvm_record_install "$current_ruby_string"
      fi

      unset current_ruby_string

      __rvm_unset_ruby_variables

      rvm_hook="after_install" ; source "$rvm_path/scripts/hook"

    done

  else # all

    if [[ "$action" != "install" && "$action" != "remove" \
      && "$action" != "uninstall" ]] ; then

      local ruby_string

      while read -r ruby_string
      do # Keep this on second line damnit!

        if [[ -x "$ruby_string" ]] ; then
          rvm_ruby_string="$ruby_string"

          eval "__rvm_${action}_ruby"
          result="$?"

          if [[ "$result" -gt 0 && "$manage_result" = 0 ]]; then
            manage_result="$result"
          fi

          # record as current_manage_string to prevent it being overridden.
          if [[ "$result" = 0 && "$action" = "install" ]] ; then
            __rvm_record_install "$ruby_string"
          fi

          __rvm_unset_ruby_variables
        fi
      done < <(builtin cd "$rvm_path/rubies" ; \
        find . -maxdepth 1 -mindepth 1 -type d 2> /dev/null | sed -e 's#./##g')

    else
      "$rvm_path/scripts/log" "warn" \
        'Really? '"$action"' all? See "rvm list known" and limit the selection to something more sane please :)'
    fi
  fi

  # TODO: This should return the exit status of the command that got called.
  return $manage_result
}

args=($*)
action="${args[0]:-""}"
rubies_string="${args[1]:-""}"
args="$(echo ${args[@]:2}) " # Strip trailing / leading / extra spacing.
binaries=()

__rvm_manage_rubies

exit $?
